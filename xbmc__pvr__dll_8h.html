<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Kodi Development: /home/alwin/Mupel/build/kodi-AlwinEsch/kodi-linux-x86_64/xbmc/addons/kodi-addon-dev-kit/kodi/xbmc_pvr_dll.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kodi-dev.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kodi Development
   &#160;<span id="projectnumber">17.0</span>
   </div>
   <div id="projectbrief">for Binary (API Level 2) and Script based Add-Ons</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xbmc__pvr__dll_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xbmc_pvr_dll.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="xbmc__addon__dll_8h_source.html">xbmc_addon_dll.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="xbmc__pvr__types_8h_source.html">xbmc_pvr_types.h</a>&quot;</code><br />
</div>
<p><a href="xbmc__pvr__dll_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac4f9255009a1339fff56333190ed601d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#ac4f9255009a1339fff56333190ed601d">__declspec</a> (dllexport) get_addon(struct <a class="el" href="struct_p_v_r_client.html">PVRClient</a> *pClient)</td></tr>
<tr class="separator:ac4f9255009a1339fff56333190ed601d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c242d4428a139d253257a462dcf1c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#ae0c242d4428a139d253257a462dcf1c7">CanPauseStream</a> ()</td></tr>
<tr class="separator:ae0c242d4428a139d253257a462dcf1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9bbd339f34d01783f3d798888c45e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a8b9bbd339f34d01783f3d798888c45e9">CanSeekStream</a> ()</td></tr>
<tr class="separator:a8b9bbd339f34d01783f3d798888c45e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd74fe4fba59f2cdf228cb0b43ca101"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#accd74fe4fba59f2cdf228cb0b43ca101">GetBackendHostname</a> ()</td></tr>
<tr class="separator:accd74fe4fba59f2cdf228cb0b43ca101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298f3b187be08ee69b37bc168ba8beff"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a298f3b187be08ee69b37bc168ba8beff">GetBufferTimeEnd</a> ()</td></tr>
<tr class="separator:a298f3b187be08ee69b37bc168ba8beff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f3f8159e029ad70067fa2f7f6bc28a"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a26f3f8159e029ad70067fa2f7f6bc28a">GetBufferTimeStart</a> ()</td></tr>
<tr class="separator:a26f3f8159e029ad70067fa2f7f6bc28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ad6d40b6e05540ed0ea9408d918004"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a53ad6d40b6e05540ed0ea9408d918004">GetChannelSwitchDelay</a> (void)</td></tr>
<tr class="separator:a53ad6d40b6e05540ed0ea9408d918004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4020cfb35e62aee4cc6b2374ae779e83"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a4020cfb35e62aee4cc6b2374ae779e83">GetPlayingTime</a> ()</td></tr>
<tr class="separator:a4020cfb35e62aee4cc6b2374ae779e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a72ec51d99448f3135899a9ea16e32e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a3a72ec51d99448f3135899a9ea16e32e">IsTimeshifting</a> ()</td></tr>
<tr class="separator:a3a72ec51d99448f3135899a9ea16e32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f43e1e9ed5b0f681b10ab67346f53fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a5f43e1e9ed5b0f681b10ab67346f53fa">PauseStream</a> (bool bPaused)</td></tr>
<tr class="memdesc:a5f43e1e9ed5b0f681b10ab67346f53fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the pvr addon that XBMC (un)paused the currently playing stream.  <a href="#a5f43e1e9ed5b0f681b10ab67346f53fa">More...</a><br /></td></tr>
<tr class="separator:a5f43e1e9ed5b0f681b10ab67346f53fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9c9f7e4f00a45aae270f46cb5d2ade"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aab9c9f7e4f00a45aae270f46cb5d2ade">SeekTime</a> (int time, bool backwards, double *startpts)</td></tr>
<tr class="separator:aab9c9f7e4f00a45aae270f46cb5d2ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64be5578c1c726e0d16e64c2554688b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a64be5578c1c726e0d16e64c2554688b5">SetSpeed</a> (int speed)</td></tr>
<tr class="separator:a64be5578c1c726e0d16e64c2554688b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR add-on methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions that the PVR client add-on must implement, but some can be empty.</p>
<p>The 'remarks' field indicates which methods should be implemented, and which ones are optional. </p>
</div></td></tr>
<tr class="memitem:abc616fbe0d4174ad3fb11dca65b39d2e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#abc616fbe0d4174ad3fb11dca65b39d2e">GetPVRAPIVersion</a> (void)</td></tr>
<tr class="separator:abc616fbe0d4174ad3fb11dca65b39d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ab7a5a12b3d12cec587c3ed72a9020"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a62ab7a5a12b3d12cec587c3ed72a9020">GetMininumPVRAPIVersion</a> (void)</td></tr>
<tr class="separator:a62ab7a5a12b3d12cec587c3ed72a9020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0618db3ed6937c5a3e8e756b61ca9d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a9c0618db3ed6937c5a3e8e756b61ca9d">GetGUIAPIVersion</a> (void)</td></tr>
<tr class="separator:a9c0618db3ed6937c5a3e8e756b61ca9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e8f36c94dab31aa615f0a5716ad93f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aa2e8f36c94dab31aa615f0a5716ad93f">GetMininumGUIAPIVersion</a> (void)</td></tr>
<tr class="separator:aa2e8f36c94dab31aa615f0a5716ad93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0ab5d23b401e2baa76c8ab3a031964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aac0ab5d23b401e2baa76c8ab3a031964">GetAddonCapabilities</a> (<a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html">PVR_ADDON_CAPABILITIES</a> *pCapabilities)</td></tr>
<tr class="separator:aac0ab5d23b401e2baa76c8ab3a031964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72e65272c6f7c7a754510e11031c477"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aa72e65272c6f7c7a754510e11031c477">GetBackendName</a> (void)</td></tr>
<tr class="separator:aa72e65272c6f7c7a754510e11031c477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090b65570876a452731b8f3d5ea68b81"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a090b65570876a452731b8f3d5ea68b81">GetBackendVersion</a> (void)</td></tr>
<tr class="separator:a090b65570876a452731b8f3d5ea68b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d0f4be840928ac03d18562152ab9a2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#ac9d0f4be840928ac03d18562152ab9a2">GetConnectionString</a> (void)</td></tr>
<tr class="separator:ac9d0f4be840928ac03d18562152ab9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ef92c952f4f98fed7031d5c14dafee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aa4ef92c952f4f98fed7031d5c14dafee">GetDriveSpace</a> (long long *iTotal, long long *iUsed)</td></tr>
<tr class="separator:aa4ef92c952f4f98fed7031d5c14dafee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ea5b651445ba01caeca6b411ac33cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a98ea5b651445ba01caeca6b411ac33cb">CallMenuHook</a> (const <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k.html">PVR_MENUHOOK</a> &amp;menuhook, const <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k___d_a_t_a.html">PVR_MENUHOOK_DATA</a> &amp;item)</td></tr>
<tr class="separator:a98ea5b651445ba01caeca6b411ac33cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR EPG methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by XBMC if bSupportsEPG is set to true. </dd></dl>
</div></td></tr>
<tr class="memitem:a357fd3786812f4de703de6609d59120e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a357fd3786812f4de703de6609d59120e">GetEPGForChannel</a> (<a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel, time_t iStart, time_t iEnd)</td></tr>
<tr class="separator:a357fd3786812f4de703de6609d59120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR channel group methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by XBMC is bSupportsChannelGroups is set to true. If a group or one of the group members changes after the initial import, or if a new one was added, then the add-on should call TriggerChannelGroupsUpdate() </dd></dl>
</div></td></tr>
<tr class="memitem:a11390f3c1ccf5981b20dbe44a313badf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a11390f3c1ccf5981b20dbe44a313badf">GetChannelGroupsAmount</a> (void)</td></tr>
<tr class="separator:a11390f3c1ccf5981b20dbe44a313badf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22095e8a9986ae55b7aec43c593fd99d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a22095e8a9986ae55b7aec43c593fd99d">GetChannelGroups</a> (<a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, bool bRadio)</td></tr>
<tr class="separator:a22095e8a9986ae55b7aec43c593fd99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ee2088f2a64853a46bda1c0b7b9ba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a58ee2088f2a64853a46bda1c0b7b9ba5">GetChannelGroupMembers</a> (<a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p.html">PVR_CHANNEL_GROUP</a> &amp;group)</td></tr>
<tr class="separator:a58ee2088f2a64853a46bda1c0b7b9ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR channel methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Either bSupportsTV or bSupportsRadio is required to be set to true. If a channel changes after the initial import, or if a new one was added, then the add-on should call TriggerChannelUpdate() </dd></dl>
</div></td></tr>
<tr class="memitem:a7ac1f5d1a6306aed664793bf839b9fe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a7ac1f5d1a6306aed664793bf839b9fe8">OpenDialogChannelScan</a> (void)</td></tr>
<tr class="separator:a7ac1f5d1a6306aed664793bf839b9fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883a3a26baf8f8e6244d14546432b8da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a883a3a26baf8f8e6244d14546432b8da">GetChannelsAmount</a> (void)</td></tr>
<tr class="separator:a883a3a26baf8f8e6244d14546432b8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dac16d985eab297347f70c03fa77713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a3dac16d985eab297347f70c03fa77713">GetChannels</a> (<a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, bool bRadio)</td></tr>
<tr class="separator:a3dac16d985eab297347f70c03fa77713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdc76aa11f2dca1fa1afe590be76f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#adcdc76aa11f2dca1fa1afe590be76f47">DeleteChannel</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:adcdc76aa11f2dca1fa1afe590be76f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac776e40ff6bc7946bc297802bf6487d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#ac776e40ff6bc7946bc297802bf6487d4">RenameChannel</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:ac776e40ff6bc7946bc297802bf6487d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ab98ddc5d5178c2dd3f80aa25a7e7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a24ab98ddc5d5178c2dd3f80aa25a7e7b">MoveChannel</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:a24ab98ddc5d5178c2dd3f80aa25a7e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e2c4ee1afe60d81cb4fefa10f98cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a16e2c4ee1afe60d81cb4fefa10f98cc6">OpenDialogChannelSettings</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:a16e2c4ee1afe60d81cb4fefa10f98cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb05ecd8b66dd9820a735ea02f4f11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aa0eb05ecd8b66dd9820a735ea02f4f11">OpenDialogChannelAdd</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:aa0eb05ecd8b66dd9820a735ea02f4f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR recording methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by XBMC is bSupportsRecordings is set to true. If a recording changes after the initial import, or if a new one was added, then the add-on should call TriggerRecordingUpdate() </dd></dl>
</div></td></tr>
<tr class="memitem:a7483fce5fadfa74152682420634a16e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a7483fce5fadfa74152682420634a16e7">GetRecordingsAmount</a> (bool deleted)</td></tr>
<tr class="separator:a7483fce5fadfa74152682420634a16e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f11b5464fd68ad226da6ff01518453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#ad6f11b5464fd68ad226da6ff01518453">GetRecordings</a> (<a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, bool deleted)</td></tr>
<tr class="separator:ad6f11b5464fd68ad226da6ff01518453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada4fc796e247b7c149ec4ca85713e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aada4fc796e247b7c149ec4ca85713e0a">DeleteRecording</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:aada4fc796e247b7c149ec4ca85713e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279c22272e7efd2ce928bc7241df4d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a279c22272e7efd2ce928bc7241df4d70">UndeleteRecording</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:a279c22272e7efd2ce928bc7241df4d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6da8dfcf7dfd645e36789b9cf16f60f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#af6da8dfcf7dfd645e36789b9cf16f60f">DeleteAllRecordingsFromTrash</a> ()</td></tr>
<tr class="memdesc:af6da8dfcf7dfd645e36789b9cf16f60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all recordings permanent which in the deleted folder on the backend.  <a href="#af6da8dfcf7dfd645e36789b9cf16f60f">More...</a><br /></td></tr>
<tr class="separator:af6da8dfcf7dfd645e36789b9cf16f60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421da11d41cfd4b37832a1eb1acc0c31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a421da11d41cfd4b37832a1eb1acc0c31">RenameRecording</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:a421da11d41cfd4b37832a1eb1acc0c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b0c5812ed0176a66f551a10a5e2b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a52b0c5812ed0176a66f551a10a5e2b4a">SetRecordingPlayCount</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording, int count)</td></tr>
<tr class="separator:a52b0c5812ed0176a66f551a10a5e2b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41b30092f3c1baf1cb492f51734962a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aa41b30092f3c1baf1cb492f51734962a">SetRecordingLastPlayedPosition</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording, int lastplayedposition)</td></tr>
<tr class="separator:aa41b30092f3c1baf1cb492f51734962a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99fd023f619717ee1cf2e0ed83a9557"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#ac99fd023f619717ee1cf2e0ed83a9557">GetRecordingLastPlayedPosition</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:ac99fd023f619717ee1cf2e0ed83a9557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f92d66918a66b9230d32350e27edbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a78f92d66918a66b9230d32350e27edbc">GetRecordingEdl</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;, <a class="el" href="struct_p_v_r___e_d_l___e_n_t_r_y.html">PVR_EDL_ENTRY</a> edl[], int *size)</td></tr>
<tr class="separator:a78f92d66918a66b9230d32350e27edbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5812c1c0d9f798f1e8c7c32553436d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a5812c1c0d9f798f1e8c7c32553436d31">GetTimerTypes</a> (<a class="el" href="struct_p_v_r___t_i_m_e_r___t_y_p_e.html">PVR_TIMER_TYPE</a> types[], int *typesCount)</td></tr>
<tr class="separator:a5812c1c0d9f798f1e8c7c32553436d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR timer methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by XBMC is bSupportsTimers is set to true. If a timer changes after the initial import, or if a new one was added, then the add-on should call TriggerTimerUpdate() </dd></dl>
</div></td></tr>
<tr class="memitem:aa1592e3d0d158bbb57f844e8cd5cc300"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aa1592e3d0d158bbb57f844e8cd5cc300">GetTimersAmount</a> (void)</td></tr>
<tr class="separator:aa1592e3d0d158bbb57f844e8cd5cc300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfa096d84f39a66a3f06cc7a73fbf99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a6bfa096d84f39a66a3f06cc7a73fbf99">GetTimers</a> (<a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle)</td></tr>
<tr class="separator:a6bfa096d84f39a66a3f06cc7a73fbf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5eee3c0ab5fd75a31a84b3905f5a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a2d5eee3c0ab5fd75a31a84b3905f5a5d">AddTimer</a> (const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;timer)</td></tr>
<tr class="separator:a2d5eee3c0ab5fd75a31a84b3905f5a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de056e3013a1db7de2b352d480b92c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a4de056e3013a1db7de2b352d480b92c0">DeleteTimer</a> (const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;timer, bool bForceDelete)</td></tr>
<tr class="separator:a4de056e3013a1db7de2b352d480b92c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcddd0448c76cf6ecf57944294eab1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a8dcddd0448c76cf6ecf57944294eab1c">UpdateTimer</a> (const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;timer)</td></tr>
<tr class="separator:a8dcddd0448c76cf6ecf57944294eab1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR live stream methods, used to open and close a stream to a channel, and optionally perform read operations on the stream</div></td></tr>
<tr class="memitem:a34e16ebfd4dd1ffd54d267ed0fee5926"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a34e16ebfd4dd1ffd54d267ed0fee5926">OpenLiveStream</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:a34e16ebfd4dd1ffd54d267ed0fee5926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd90a3e10a7f29fa19a6eaf88487f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a4fd90a3e10a7f29fa19a6eaf88487f5c">CloseLiveStream</a> (void)</td></tr>
<tr class="separator:a4fd90a3e10a7f29fa19a6eaf88487f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a31f12e57e4184a5c07eb9edff24a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#af0a31f12e57e4184a5c07eb9edff24a6">ReadLiveStream</a> (unsigned char *pBuffer, unsigned int iBufferSize)</td></tr>
<tr class="separator:af0a31f12e57e4184a5c07eb9edff24a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d0504fc5ea4ad43fcce9a792e2235"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a682d0504fc5ea4ad43fcce9a792e2235">SeekLiveStream</a> (long long iPosition, int iWhence=SEEK_SET)</td></tr>
<tr class="separator:a682d0504fc5ea4ad43fcce9a792e2235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fae762b85217a2115578931e5b9cdb"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a73fae762b85217a2115578931e5b9cdb">PositionLiveStream</a> (void)</td></tr>
<tr class="separator:a73fae762b85217a2115578931e5b9cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325f78efd806b9009385a2fba534ed66"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a325f78efd806b9009385a2fba534ed66">LengthLiveStream</a> (void)</td></tr>
<tr class="separator:a325f78efd806b9009385a2fba534ed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48ae696bb13c9d88156875c52d3e49a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aa48ae696bb13c9d88156875c52d3e49a">GetCurrentClientChannel</a> (void)</td></tr>
<tr class="separator:aa48ae696bb13c9d88156875c52d3e49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21560dda33517ff6bf7feaf2cd7938ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a21560dda33517ff6bf7feaf2cd7938ee">SwitchChannel</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:a21560dda33517ff6bf7feaf2cd7938ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d00d56e097ce1ccc277456434c91da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a2d00d56e097ce1ccc277456434c91da3">SignalStatus</a> (<a class="el" href="struct_p_v_r___s_i_g_n_a_l___s_t_a_t_u_s.html">PVR_SIGNAL_STATUS</a> &amp;signalStatus)</td></tr>
<tr class="separator:a2d00d56e097ce1ccc277456434c91da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8b53c8efa40afaacd19347ea6cdecc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a3c8b53c8efa40afaacd19347ea6cdecc">GetLiveStreamURL</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:a3c8b53c8efa40afaacd19347ea6cdecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbd12115e41104682ad9b380329626d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a8dbd12115e41104682ad9b380329626d">GetStreamProperties</a> (<a class="el" href="struct_p_v_r___s_t_r_e_a_m___p_r_o_p_e_r_t_i_e_s.html">PVR_STREAM_PROPERTIES</a> *pProperties)</td></tr>
<tr class="separator:a8dbd12115e41104682ad9b380329626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR recording stream methods, used to open and close a stream to a recording, and perform read operations on the stream.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>This will only be used if the backend doesn't provide a direct URL in the recording tag. </dd></dl>
</div></td></tr>
<tr class="memitem:af8e34b64d68ed640ceb05ada10e4158b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#af8e34b64d68ed640ceb05ada10e4158b">OpenRecordedStream</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:af8e34b64d68ed640ceb05ada10e4158b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485bde72341ec4380c8b58591d4f3628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a485bde72341ec4380c8b58591d4f3628">CloseRecordedStream</a> (void)</td></tr>
<tr class="separator:a485bde72341ec4380c8b58591d4f3628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e954f136a0faff36ba757f419759a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a10e954f136a0faff36ba757f419759a1">ReadRecordedStream</a> (unsigned char *pBuffer, unsigned int iBufferSize)</td></tr>
<tr class="separator:a10e954f136a0faff36ba757f419759a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fd6f7debd84688a73b35fdb765f7bf"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aa3fd6f7debd84688a73b35fdb765f7bf">SeekRecordedStream</a> (long long iPosition, int iWhence=SEEK_SET)</td></tr>
<tr class="separator:aa3fd6f7debd84688a73b35fdb765f7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482b845d1e94a70dc3e6dac436483955"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a482b845d1e94a70dc3e6dac436483955">PositionRecordedStream</a> (void)</td></tr>
<tr class="separator:a482b845d1e94a70dc3e6dac436483955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ef7cbfaaa1d04cf0ddd3cd6a3eb695"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a68ef7cbfaaa1d04cf0ddd3cd6a3eb695">LengthRecordedStream</a> (void)</td></tr>
<tr class="separator:a68ef7cbfaaa1d04cf0ddd3cd6a3eb695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR demultiplexer methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by XBMC is bHandlesDemuxing is set to true. </dd></dl>
</div></td></tr>
<tr class="memitem:a23ff1629066ecead29fd4d6e5aea81df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a23ff1629066ecead29fd4d6e5aea81df">DemuxReset</a> (void)</td></tr>
<tr class="separator:a23ff1629066ecead29fd4d6e5aea81df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aee9823847ec05ffa8c5e6b40a767d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#a45aee9823847ec05ffa8c5e6b40a767d">DemuxAbort</a> (void)</td></tr>
<tr class="separator:a45aee9823847ec05ffa8c5e6b40a767d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa536f2ec63f8666013cab3a9e9879531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#aa536f2ec63f8666013cab3a9e9879531">DemuxFlush</a> (void)</td></tr>
<tr class="separator:aa536f2ec63f8666013cab3a9e9879531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac982090cb3eb0a90e11a765c31a86b34"><td class="memItemLeft" align="right" valign="top">DemuxPacket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbmc__pvr__dll_8h.html#ac982090cb3eb0a90e11a765c31a86b34">DemuxRead</a> (void)</td></tr>
<tr class="separator:ac982090cb3eb0a90e11a765c31a86b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac4f9255009a1339fff56333190ed601d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __declspec </td>
          <td>(</td>
          <td class="paramtype">dllexport&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by XBMC to assign the function pointers of this add-on to pClient. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClient</td><td>The struct to assign the function pointers to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d5eee3c0ab5fd75a31a84b3905f5a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> AddTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a timer on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the timer has been added successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a98ea5b651445ba01caeca6b411ac33cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> CallMenuHook </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k.html">PVR_MENUHOOK</a> &amp;&#160;</td>
          <td class="paramname"><em>menuhook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k___d_a_t_a.html">PVR_MENUHOOK_DATA</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call one of the menu hooks (if supported). Supported <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k.html" title="Menu hooks that are available in the context menus while playing a stream via this add-on...">PVR_MENUHOOK</a> instances have to be added in ADDON_Create(), by calling AddMenuHook() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">menuhook</td><td>The hook to call. </td></tr>
    <tr><td class="paramname">item</td><td>The selected item for which the hook was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the hook was called successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0c242d4428a139d253257a462dcf1c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CanPauseStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the backend support pausing the currently playing stream This will enable/disable the pause button in XBMC based on the return value </p><dl class="section return"><dt>Returns</dt><dd>false if the PVR addon/backend does not support pausing, true if possible </dd></dl>

</div>
</div>
<a class="anchor" id="a8b9bbd339f34d01783f3d798888c45e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CanSeekStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the backend supports seeking for the currently playing stream This will enable/disable the rewind/forward buttons in XBMC based on the return value </p><dl class="section return"><dt>Returns</dt><dd>false if the PVR addon/backend does not support seeking, true if possible </dd></dl>

</div>
</div>
<a class="anchor" id="a4fd90a3e10a7f29fa19a6eaf88487f5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CloseLiveStream </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an open live stream. </p><dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesInputStream or bHandlesDemuxing is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a485bde72341ec4380c8b58591d4f3628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CloseRecordedStream </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an open stream from a recording. </p><dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="af6da8dfcf7dfd645e36789b9cf16f60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> DeleteAllRecordingsFromTrash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all recordings permanent which in the deleted folder on the backend. </p>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recordings has been deleted successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="adcdc76aa11f2dca1fa1afe590be76f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> DeleteChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a channel from the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been deleted successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelSettings is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="aada4fc796e247b7c149ec4ca85713e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> DeleteRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording has been deleted successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a4de056e3013a1db7de2b352d480b92c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> DeleteTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bForceDelete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a timer on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer to delete. </td></tr>
    <tr><td class="paramname">bForceDelete</td><td>Set to true to delete a timer that is currently recording a program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the timer has been deleted successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a45aee9823847ec05ffa8c5e6b40a767d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DemuxAbort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abort the demultiplexer thread in the add-on. </p><dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesDemuxing is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="aa536f2ec63f8666013cab3a9e9879531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DemuxFlush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush all data that's currently in the demultiplexer buffer in the add-on. </p><dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesDemuxing is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="ac982090cb3eb0a90e11a765c31a86b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DemuxPacket* DemuxRead </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next packet from the demultiplexer, if there is one. </p><dl class="section return"><dt>Returns</dt><dd>The next packet. If there is no next packet, then the add-on should return the packet created by calling AllocateDemuxPacket(0) on the callback. If the stream changed and XBMC's player needs to be reinitialised, then, the add-on should call AllocateDemuxPacket(0) on the callback, and set the streamid to DMX_SPECIALID_STREAMCHANGE and return the value. The add-on should return NULL if an error occured. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesDemuxing is set to true. Return NULL if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a23ff1629066ecead29fd4d6e5aea81df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DemuxReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the demultiplexer in the add-on. </p><dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesDemuxing is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="aac0ab5d23b401e2baa76c8ab3a031964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetAddonCapabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html">PVR_ADDON_CAPABILITIES</a> *&#160;</td>
          <td class="paramname"><em>pCapabilities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the list of features that this add-on provides. Called by XBMC to query the add-on's capabilities. Used to check which options should be presented in the UI, which methods to call, etc. All capabilities that the add-on supports should be set to true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCapabilities</td><td>The add-on's capabilities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the properties were fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="accd74fe4fba59f2cdf228cb0b43ca101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GetBackendHostname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the hostname of the pvr backend server </p><dl class="section return"><dt>Returns</dt><dd>hostname as ip address or alias. If backend does not utilize a server, return empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="aa72e65272c6f7c7a754510e11031c477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GetBackendName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The name reported by the backend that will be displayed in the UI. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a090b65570876a452731b8f3d5ea68b81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GetBackendVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The version string reported by the backend that will be displayed in the UI. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a298f3b187be08ee69b37bc168ba8beff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t GetBufferTimeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get time of latest packet in timeshift buffer </p><dl class="section return"><dt>Returns</dt><dd>time as UTC </dd></dl>

</div>
</div>
<a class="anchor" id="a26f3f8159e029ad70067fa2f7f6bc28a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t GetBufferTimeStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get time of oldest packet in timeshift buffer </p><dl class="section return"><dt>Returns</dt><dd>time as UTC </dd></dl>

</div>
</div>
<a class="anchor" id="a58ee2088f2a64853a46bda1c0b7b9ba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetChannelGroupMembers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p.html">PVR_CHANNEL_GROUP</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request the list of all group members of a group from the backend if it supports channel groups. Member entries are added to XBMC by calling TransferChannelGroupMember() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">group</td><td>The group to get the members for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelGroups is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a22095e8a9986ae55b7aec43c593fd99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetChannelGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRadio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request the list of all channel groups from the backend if it supports channel groups. Channel group entries are added to XBMC by calling TransferChannelGroup() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">bRadio</td><td>True to get the radio channel groups, false to get the TV channel groups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelGroups is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a11390f3c1ccf5981b20dbe44a313badf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetChannelGroupsAmount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total amount of channel groups on the backend if it supports channel groups. </p><dl class="section return"><dt>Returns</dt><dd>The amount of channels, or -1 on error. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelGroups is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dac16d985eab297347f70c03fa77713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRadio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request the list of all channels from the backend. Channel entries are added to XBMC by calling TransferChannelEntry() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">bRadio</td><td>True to get the radio channels, false to get the TV channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If bSupportsTV is set to true, a valid result set needs to be provided for bRadio = false. If bSupportsRadio is set to true, a valid result set needs to be provided for bRadio = true. At least one of these two must provide a valid result set. </dd></dl>

</div>
</div>
<a class="anchor" id="a883a3a26baf8f8e6244d14546432b8da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetChannelsAmount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total amount of channels on the backend, or -1 on error. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a53ad6d40b6e05540ed0ea9408d918004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetChannelSwitchDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay to use when using switching channels for add-ons not providing an input stream. If the add-on does provide an input stream, then this method will not be called. Those add-ons can do that in <a class="el" href="xbmc__pvr__dll_8h.html#a34e16ebfd4dd1ffd54d267ed0fee5926">OpenLiveStream()</a> if needed. </p><dl class="section return"><dt>Returns</dt><dd>The delay in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9d0f4be840928ac03d18562152ab9a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GetConnectionString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The connection string reported by the backend that will be displayed in the UI. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="aa48ae696bb13c9d88156875c52d3e49a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetCurrentClientChannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The channel number on the backend of the live stream that's currently being read. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesInputStream or bHandlesDemuxing is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4ef92c952f4f98fed7031d5c14dafee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetDriveSpace </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>iTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>iUsed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the disk space reported by the backend (if supported). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iTotal</td><td>The total disk space in bytes. </td></tr>
    <tr><td class="paramname">iUsed</td><td>The used disk space in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the drive space has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a357fd3786812f4de703de6609d59120e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetEPGForChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>iStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>iEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request the EPG for a channel from the backend. EPG entries are added to XBMC by calling TransferEpgEntry() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">channel</td><td>The channel to get the EPG table for. </td></tr>
    <tr><td class="paramname">iStart</td><td>Get events after this time (UTC). </td></tr>
    <tr><td class="paramname">iEnd</td><td>Get events before this time (UTC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the table has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsEPG is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c0618db3ed6937c5a3e8e756b61ca9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GetGUIAPIVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the XBMC_GUI_API_VERSION that was used to compile this add-on. Used to check if this add-on is compatible with XBMC. </p><dl class="section return"><dt>Returns</dt><dd>The XBMC_GUI_API_VERSION that was used to compile this add-on. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c8b53c8efa40afaacd19347ea6cdecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GetLiveStreamURL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the stream URL for a channel from the backend. Used by the MediaPortal add-on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to get the stream URL for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested URL. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bHandlesInputStream is set to true. Return NULL if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2e8f36c94dab31aa615f0a5716ad93f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GetMininumGUIAPIVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the XBMC_GUI_MIN_API_VERSION that was used to compile this add-on. Used to check if this add-on is compatible with XBMC. </p><dl class="section return"><dt>Returns</dt><dd>The XBMC_GUI_MIN_API_VERSION that was used to compile this add-on. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a62ab7a5a12b3d12cec587c3ed72a9020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GetMininumPVRAPIVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the XBMC_PVR_MIN_API_VERSION that was used to compile this add-on. Used to check if this add-on is compatible with XBMC. </p><dl class="section return"><dt>Returns</dt><dd>The XBMC_PVR_MIN_API_VERSION that was used to compile this add-on. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a4020cfb35e62aee4cc6b2374ae779e83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t GetPlayingTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get actual playing time from addon. With timeshift enabled this is different to live. </p><dl class="section return"><dt>Returns</dt><dd>time as UTC </dd></dl>

</div>
</div>
<a class="anchor" id="abc616fbe0d4174ad3fb11dca65b39d2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GetPVRAPIVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the XBMC_PVR_API_VERSION that was used to compile this add-on. Used to check if this add-on is compatible with XBMC. </p><dl class="section return"><dt>Returns</dt><dd>The XBMC_PVR_API_VERSION that was used to compile this add-on. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a78f92d66918a66b9230d32350e27edbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetRecordingEdl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p_v_r___e_d_l___e_n_t_r_y.html">PVR_EDL_ENTRY</a>&#160;</td>
          <td class="paramname"><em>edl</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the edit decision list (EDL) of a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording. </td></tr>
    <tr><td class="paramname">edl</td><td>out: The function has to write the EDL list into this array. </td></tr>
    <tr><td class="paramname">size</td><td>in: The maximum size of the EDL, out: the actual size of the EDL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the EDL was successfully read. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordingEdl is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac99fd023f619717ee1cf2e0ed83a9557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetRecordingLastPlayedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the last watched position of a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last watched position in seconds or -1 on error </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordingPlayCount is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6f11b5464fd68ad226da6ff01518453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetRecordings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request the list of all recordings from the backend, if supported. Recording entries are added to XBMC by calling TransferRecordingEntry() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">deleted</td><td>if set return deleted recording (called if bSupportsRecordingsUndelete set to true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recordings have been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a7483fce5fadfa74152682420634a16e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetRecordingsAmount </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total amount of recordings on the backend or -1 on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleted</td><td>if set return deleted recording (called if bSupportsRecordingsUndelete set to true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dbd12115e41104682ad9b380329626d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetStreamProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_v_r___s_t_r_e_a_m___p_r_o_p_e_r_t_i_e_s.html">PVR_STREAM_PROPERTIES</a> *&#160;</td>
          <td class="paramname"><em>pProperties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the stream properties of the stream that's currently being read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProperties</td><td>The properties of the currently playing stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the properties have been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesInputStream or bHandlesDemuxing is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bfa096d84f39a66a3f06cc7a73fbf99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetTimers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xbmc__addon__types_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request the list of all timers from the backend if supported. Timer entries are added to XBMC by calling TransferTimerEntry() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1592e3d0d158bbb57f844e8cd5cc300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetTimersAmount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total amount of timers on the backend or -1 on error. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5812c1c0d9f798f1e8c7c32553436d31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetTimerTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_v_r___t_i_m_e_r___t_y_p_e.html">PVR_TIMER_TYPE</a>&#160;</td>
          <td class="paramname"><em>types</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>typesCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the timer types supported by the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>out: The function has to write the definition of the supported timer types into this array. </td></tr>
    <tr><td class="paramname">typesCount</td><td>in: The maximum size of the list, out: the actual size of the list. default: PVR_ADDON_TIMERTYPE_ARRAY_SIZE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the types were successfully written to the array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a72ec51d99448f3135899a9ea16e32e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsTimeshifting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if timeshift is active </p><dl class="section return"><dt>Returns</dt><dd>true if timeshift is active </dd></dl>

</div>
</div>
<a class="anchor" id="a325f78efd806b9009385a2fba534ed66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long LengthLiveStream </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total length of the stream that's currently being read. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bHandlesInputStream is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a68ef7cbfaaa1d04cf0ddd3cd6a3eb695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long LengthRecordedStream </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total length of the stream that's currently being read. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a24ab98ddc5d5178c2dd3f80aa25a7e7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> MoveChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move a channel to another channel number on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to move, containing the new channel number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been moved successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsChannelSettings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0eb05ecd8b66dd9820a735ea02f4f11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> OpenDialogChannelAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Show the dialog to add a channel on the backend, if supported by the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been added successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelSettings is set to true. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see <a class="el" href="lib_k_o_d_i__guilib_8h.html">libKODI_guilib.h</a> about related parts </dd></dl>

</div>
</div>
<a class="anchor" id="a7ac1f5d1a6306aed664793bf839b9fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> OpenDialogChannelScan </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Show the channel scan dialog if this backend supports it. </p><dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the dialog was displayed successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelScan is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see <a class="el" href="lib_k_o_d_i__guilib_8h.html">libKODI_guilib.h</a> about related parts </dd></dl>

</div>
</div>
<a class="anchor" id="a16e2c4ee1afe60d81cb4fefa10f98cc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> OpenDialogChannelSettings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Show the channel settings dialog, if supported by the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to show the dialog for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the dialog has been displayed successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelSettings is set to true. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see <a class="el" href="lib_k_o_d_i__guilib_8h.html">libKODI_guilib.h</a> about related parts </dd></dl>

</div>
</div>
<a class="anchor" id="a34e16ebfd4dd1ffd54d267ed0fee5926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLiveStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a live stream on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has been opened successfully, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesInputStream or bHandlesDemuxing is set to true. Return false if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="af8e34b64d68ed640ceb05ada10e4158b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenRecordedStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a stream to a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has been opened successfully, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return false if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f43e1e9ed5b0f681b10ab67346f53fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PauseStream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPaused</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the pvr addon that XBMC (un)paused the currently playing stream. </p>

</div>
</div>
<a class="anchor" id="a73fae762b85217a2115578931e5b9cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long PositionLiveStream </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The position in the stream that's currently being read. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bHandlesInputStream is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a482b845d1e94a70dc3e6dac436483955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long PositionRecordedStream </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The position in the stream that's currently being read. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="af0a31f12e57e4184a5c07eb9edff24a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReadLiveStream </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from an open live stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramname">iBufferSize</td><td>The amount of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of bytes that were actually read from the stream. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesInputStream is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a10e954f136a0faff36ba757f419759a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReadRecordedStream </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from a recording. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramname">iBufferSize</td><td>The amount of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of bytes that were actually read from the stream. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true, but required if <a class="el" href="xbmc__pvr__dll_8h.html#af8e34b64d68ed640ceb05ada10e4158b">OpenRecordedStream()</a> is implemented. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac776e40ff6bc7946bc297802bf6487d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> RenameChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rename a channel on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to rename, containing the new channel name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been renamed successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsChannelSettings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a421da11d41cfd4b37832a1eb1acc0c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> RenameRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rename a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to rename, containing the new name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording has been renamed successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a682d0504fc5ea4ad43fcce9a792e2235"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long SeekLiveStream </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>iPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWhence</em> = <code>SEEK_SET</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seek in a live stream on a backend that supports timeshifting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iPosition</td><td>The position to seek to. </td></tr>
    <tr><td class="paramname">iWhence</td><td>? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bHandlesInputStream is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3fd6f7debd84688a73b35fdb765f7bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long SeekRecordedStream </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>iPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWhence</em> = <code>SEEK_SET</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seek in a recorded stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iPosition</td><td>The position to seek to. </td></tr>
    <tr><td class="paramname">iWhence</td><td>? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aab9c9f7e4f00a45aae270f46cb5d2ade"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SeekTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backwards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>startpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify the pvr addon/demuxer that XBMC wishes to seek the stream by time </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The absolute time since stream start </td></tr>
    <tr><td class="paramname">backwards</td><td>True to seek to keyframe BEFORE time, else AFTER </td></tr>
    <tr><td class="paramname">startpts</td><td>can be updated to point to where display should start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the seek operation was possible </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if addon has its own demuxer. Return False if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aa41b30092f3c1baf1cb492f51734962a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> SetRecordingLastPlayedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lastplayedposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the last watched position of a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording. </td></tr>
    <tr><td class="paramname">position</td><td>The last watched position in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the position has been stored successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsLastPlayedPosition is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a52b0c5812ed0176a66f551a10a5e2b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> SetRecordingPlayCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the play count of a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to change the play count. </td></tr>
    <tr><td class="paramname">count</td><td>Play count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording's play count has been set successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordingPlayCount is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a64be5578c1c726e0d16e64c2554688b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSpeed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify the pvr addon/demuxer that XBMC wishes to change playback speed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>The requested playback speed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if addon has its own demuxer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d00d56e097ce1ccc277456434c91da3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> SignalStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_v_r___s_i_g_n_a_l___s_t_a_t_u_s.html">PVR_SIGNAL_STATUS</a> &amp;&#160;</td>
          <td class="paramname"><em>signalStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the signal status of the stream that's currently open. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signalStatus</td><td>The signal status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the signal status has been read successfully, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bHandlesInputStream or bHandlesDemuxing is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a21560dda33517ff6bf7feaf2cd7938ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SwitchChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch to another channel. Only to be called when a live stream has already been opened. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to switch to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the switch was successful, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesInputStream or bHandlesDemuxing is set to true. Return false if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a279c22272e7efd2ce928bc7241df4d70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> UndeleteRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Undelete a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to undelete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording has been undeleted successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordingsUndelete is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dcddd0448c76cf6ecf57944294eab1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> UpdateTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the timer information on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the timer has been updated successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ddf45245cea9976875b29d8e0ec306b1.html">kodi</a></li><li class="navelem"><a class="el" href="xbmc__pvr__dll_8h.html">xbmc_pvr_dll.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
