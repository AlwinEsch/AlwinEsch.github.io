<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Kodi Development: CAddon</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kodi-dev.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kodi Development
   &#160;<span id="projectnumber">17.0</span>
   </div>
   <div id="projectbrief">for Binary (API Level 2) and Script based Add-Ons</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classkodi_1_1addon_1_1pvr_1_1_c_addon.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkodi_1_1addon_1_1pvr_1_1_c_addon-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CAddon<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a45884e189fad76597699caa992574bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a45884e189fad76597699caa992574bef">AddMenuHook</a> (<a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k.html">PVR_MENUHOOK</a> *hook)</td></tr>
<tr class="memdesc:a45884e189fad76597699caa992574bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or replace a menu hook for the context menu for this add-on.  <a href="#a45884e189fad76597699caa992574bef">More...</a><br /></td></tr>
<tr class="separator:a45884e189fad76597699caa992574bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab3abc659d82c4f8eea839e37c1dc15"><td class="memItemLeft" align="right" valign="top">DemuxPacket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#afab3abc659d82c4f8eea839e37c1dc15">AllocateDemuxPacket</a> (int datasize)</td></tr>
<tr class="memdesc:afab3abc659d82c4f8eea839e37c1dc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a demux packet. Free with FreeDemuxPacket.  <a href="#afab3abc659d82c4f8eea839e37c1dc15">More...</a><br /></td></tr>
<tr class="separator:afab3abc659d82c4f8eea839e37c1dc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89343289dac30a826b80aaafb104f411"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a89343289dac30a826b80aaafb104f411">CAddon</a> (void *instance)</td></tr>
<tr class="memdesc:a89343289dac30a826b80aaafb104f411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor.  <a href="#a89343289dac30a826b80aaafb104f411">More...</a><br /></td></tr>
<tr class="separator:a89343289dac30a826b80aaafb104f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e12689cdfcd579b9e5d360c1b5aeff"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a86e12689cdfcd579b9e5d360c1b5aeff">CanPauseStream</a> ()</td></tr>
<tr class="memdesc:a86e12689cdfcd579b9e5d360c1b5aeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the backend support pausing the currently playing stream.  <a href="#a86e12689cdfcd579b9e5d360c1b5aeff">More...</a><br /></td></tr>
<tr class="separator:a86e12689cdfcd579b9e5d360c1b5aeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8b23e2807b46abb712ec1cfcee6ac8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#afd8b23e2807b46abb712ec1cfcee6ac8">CanSeekStream</a> ()</td></tr>
<tr class="memdesc:afd8b23e2807b46abb712ec1cfcee6ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the backend supports seeking for the currently playing stream.  <a href="#afd8b23e2807b46abb712ec1cfcee6ac8">More...</a><br /></td></tr>
<tr class="separator:afd8b23e2807b46abb712ec1cfcee6ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff13d27354254cac06c10b1d70a1dc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a8ff13d27354254cac06c10b1d70a1dc9">ConnectionStateChange</a> (std::string connectionString, PVR_CONNECTION_STATE newState, std::string message)</td></tr>
<tr class="memdesc:a8ff13d27354254cac06c10b1d70a1dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify a state change for a PVR backend connection.  <a href="#a8ff13d27354254cac06c10b1d70a1dc9">More...</a><br /></td></tr>
<tr class="separator:a8ff13d27354254cac06c10b1d70a1dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8795247dea7a40ac72ac8102c06f7cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a8795247dea7a40ac72ac8102c06f7cb7">EpgEventStateChange</a> (<a class="el" href="struct_e_p_g___t_a_g.html">EPG_TAG</a> *tag, unsigned int uniqueChannelId, EPG_EVENT_STATE newState)</td></tr>
<tr class="memdesc:a8795247dea7a40ac72ac8102c06f7cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify a state change for an EPG event.  <a href="#a8795247dea7a40ac72ac8102c06f7cb7">More...</a><br /></td></tr>
<tr class="separator:a8795247dea7a40ac72ac8102c06f7cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27de47f3d3787e878ab521d9ca3cf479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a27de47f3d3787e878ab521d9ca3cf479">FreeDemuxPacket</a> (DemuxPacket *packet)</td></tr>
<tr class="memdesc:a27de47f3d3787e878ab521d9ca3cf479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a packet that was allocated with AllocateDemuxPacket.  <a href="#a27de47f3d3787e878ab521d9ca3cf479">More...</a><br /></td></tr>
<tr class="separator:a27de47f3d3787e878ab521d9ca3cf479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add87d3c165c0bb6171c39f6ef4f5bdb0"><td class="memItemLeft" align="right" valign="top">virtual time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#add87d3c165c0bb6171c39f6ef4f5bdb0">GetBufferTimeEnd</a> ()</td></tr>
<tr class="memdesc:add87d3c165c0bb6171c39f6ef4f5bdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get time of latest packet in timeshift buffer.  <a href="#add87d3c165c0bb6171c39f6ef4f5bdb0">More...</a><br /></td></tr>
<tr class="separator:add87d3c165c0bb6171c39f6ef4f5bdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d580744a08d5fcf9773d55a9b49036"><td class="memItemLeft" align="right" valign="top">virtual time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a80d580744a08d5fcf9773d55a9b49036">GetBufferTimeStart</a> ()</td></tr>
<tr class="memdesc:a80d580744a08d5fcf9773d55a9b49036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get time of oldest packet in timeshift buffer.  <a href="#a80d580744a08d5fcf9773d55a9b49036">More...</a><br /></td></tr>
<tr class="separator:a80d580744a08d5fcf9773d55a9b49036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f1f5a17b2e2ddc9f35b6ca8196a44"><td class="memItemLeft" align="right" valign="top">virtual time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a227f1f5a17b2e2ddc9f35b6ca8196a44">GetPlayingTime</a> ()</td></tr>
<tr class="memdesc:a227f1f5a17b2e2ddc9f35b6ca8196a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get actual playing time from addon.  <a href="#a227f1f5a17b2e2ddc9f35b6ca8196a44">More...</a><br /></td></tr>
<tr class="separator:a227f1f5a17b2e2ddc9f35b6ca8196a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad550e498369f3a406296779a162ec04"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#aad550e498369f3a406296779a162ec04">IsRealTimeStream</a> ()</td></tr>
<tr class="memdesc:aad550e498369f3a406296779a162ec04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for real-time streaming.  <a href="#aad550e498369f3a406296779a162ec04">More...</a><br /></td></tr>
<tr class="separator:aad550e498369f3a406296779a162ec04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51098c2791f68b2e53f0e0ec88165ea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#aa51098c2791f68b2e53f0e0ec88165ea">IsTimeshifting</a> ()</td></tr>
<tr class="memdesc:aa51098c2791f68b2e53f0e0ec88165ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if timeshift is active.  <a href="#aa51098c2791f68b2e53f0e0ec88165ea">More...</a><br /></td></tr>
<tr class="separator:aa51098c2791f68b2e53f0e0ec88165ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7da84be98ff5caee3664d3b3f048ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a3f7da84be98ff5caee3664d3b3f048ed">OnPowerSavingActivated</a> ()</td></tr>
<tr class="memdesc:a3f7da84be98ff5caee3664d3b3f048ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the pvr addon that power saving becomes activated.  <a href="#a3f7da84be98ff5caee3664d3b3f048ed">More...</a><br /></td></tr>
<tr class="separator:a3f7da84be98ff5caee3664d3b3f048ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6bfc517164b97eba15cc0e463c43b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a0f6bfc517164b97eba15cc0e463c43b0">OnPowerSavingDeactivated</a> ()</td></tr>
<tr class="memdesc:a0f6bfc517164b97eba15cc0e463c43b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the pvr addon about power saving becomes deactivated.  <a href="#a0f6bfc517164b97eba15cc0e463c43b0">More...</a><br /></td></tr>
<tr class="separator:a0f6bfc517164b97eba15cc0e463c43b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97826feca391a64d78e922fd2778a12c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a97826feca391a64d78e922fd2778a12c">OnSystemSleep</a> ()</td></tr>
<tr class="memdesc:a97826feca391a64d78e922fd2778a12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the pvr addon for power management events.  <a href="#a97826feca391a64d78e922fd2778a12c">More...</a><br /></td></tr>
<tr class="separator:a97826feca391a64d78e922fd2778a12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefee487397aab89c0515ff3a7e0ffaaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#aefee487397aab89c0515ff3a7e0ffaaa">OnSystemWake</a> ()</td></tr>
<tr class="memdesc:aefee487397aab89c0515ff3a7e0ffaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the pvr addon about a system wake event.  <a href="#aefee487397aab89c0515ff3a7e0ffaaa">More...</a><br /></td></tr>
<tr class="separator:aefee487397aab89c0515ff3a7e0ffaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2158722d1f7f740a518e47b575fb4df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ac2158722d1f7f740a518e47b575fb4df">PauseStream</a> (bool paused)</td></tr>
<tr class="memdesc:ac2158722d1f7f740a518e47b575fb4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the pvr addon that Kodi (un)paused the currently playing stream.  <a href="#ac2158722d1f7f740a518e47b575fb4df">More...</a><br /></td></tr>
<tr class="separator:ac2158722d1f7f740a518e47b575fb4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679068487db30ffd566e43e925ba603a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a679068487db30ffd566e43e925ba603a">Recording</a> (std::string recordingname, std::string filename, bool on)</td></tr>
<tr class="memdesc:a679068487db30ffd566e43e925ba603a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a notification in Kodi that a recording started or stopped on the server.  <a href="#a679068487db30ffd566e43e925ba603a">More...</a><br /></td></tr>
<tr class="separator:a679068487db30ffd566e43e925ba603a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bed940e124a0ba99a159d1679e5598b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a8bed940e124a0ba99a159d1679e5598b">SeekTime</a> (int time, bool backwards, double &amp;startpts)</td></tr>
<tr class="memdesc:a8bed940e124a0ba99a159d1679e5598b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the pvr addon/demuxer that Kodi wishes to seek the stream by time.  <a href="#a8bed940e124a0ba99a159d1679e5598b">More...</a><br /></td></tr>
<tr class="separator:a8bed940e124a0ba99a159d1679e5598b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20d7d09d75d3f1bf568e7d5475893bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ab20d7d09d75d3f1bf568e7d5475893bb">SetSpeed</a> (int speed)</td></tr>
<tr class="memdesc:ab20d7d09d75d3f1bf568e7d5475893bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the pvr addon/demuxer that Kodi wishes to change playback speed.  <a href="#ab20d7d09d75d3f1bf568e7d5475893bb">More...</a><br /></td></tr>
<tr class="separator:ab20d7d09d75d3f1bf568e7d5475893bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935da613c39f91145b6f230728bb1df0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a935da613c39f91145b6f230728bb1df0">TriggerChannelGroupsUpdate</a> (void)</td></tr>
<tr class="memdesc:a935da613c39f91145b6f230728bb1df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request Kodi to update it's list of channel groups.  <a href="#a935da613c39f91145b6f230728bb1df0">More...</a><br /></td></tr>
<tr class="separator:a935da613c39f91145b6f230728bb1df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be8a63a1bde169779281dff66e50014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a0be8a63a1bde169779281dff66e50014">TriggerChannelUpdate</a> (void)</td></tr>
<tr class="memdesc:a0be8a63a1bde169779281dff66e50014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request Kodi to update it's list of channels.  <a href="#a0be8a63a1bde169779281dff66e50014">More...</a><br /></td></tr>
<tr class="separator:a0be8a63a1bde169779281dff66e50014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2497b4db59f21f2fbb2956dc016c3067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a2497b4db59f21f2fbb2956dc016c3067">TriggerEpgUpdate</a> (unsigned int channelUid)</td></tr>
<tr class="memdesc:a2497b4db59f21f2fbb2956dc016c3067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an EPG update for the given channel channel.  <a href="#a2497b4db59f21f2fbb2956dc016c3067">More...</a><br /></td></tr>
<tr class="separator:a2497b4db59f21f2fbb2956dc016c3067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32558a6dec1bee47462379c7fb11dc1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a32558a6dec1bee47462379c7fb11dc1a">TriggerRecordingUpdate</a> (void)</td></tr>
<tr class="memdesc:a32558a6dec1bee47462379c7fb11dc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request Kodi to update it's list of recordings.  <a href="#a32558a6dec1bee47462379c7fb11dc1a">More...</a><br /></td></tr>
<tr class="separator:a32558a6dec1bee47462379c7fb11dc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a28ab2aa9e2f3191c2d6281cdc680ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a7a28ab2aa9e2f3191c2d6281cdc680ee">TriggerTimerUpdate</a> (void)</td></tr>
<tr class="memdesc:a7a28ab2aa9e2f3191c2d6281cdc680ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request Kodi to update it's list of timers.  <a href="#a7a28ab2aa9e2f3191c2d6281cdc680ee">More...</a><br /></td></tr>
<tr class="separator:a7a28ab2aa9e2f3191c2d6281cdc680ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR add-on methods</div></td></tr>
<tr class="memitem:a7ae98b714d1be647177c75cdc8657455"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a7ae98b714d1be647177c75cdc8657455">GetCapabilities</a> (<a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html">PVR_ADDON_CAPABILITIES</a> &amp;capabilities)=0</td></tr>
<tr class="memdesc:a7ae98b714d1be647177c75cdc8657455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of features that this add-on provides.  <a href="#a7ae98b714d1be647177c75cdc8657455">More...</a><br /></td></tr>
<tr class="separator:a7ae98b714d1be647177c75cdc8657455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d08c3fcded44c002c5f7af63f2c0dfc"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a5d08c3fcded44c002c5f7af63f2c0dfc">GetBackendName</a> ()=0</td></tr>
<tr class="memdesc:a5d08c3fcded44c002c5f7af63f2c0dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PVR add-ons backend name.  <a href="#a5d08c3fcded44c002c5f7af63f2c0dfc">More...</a><br /></td></tr>
<tr class="separator:a5d08c3fcded44c002c5f7af63f2c0dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fe4615508be9f8a66a09be380c5b58"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a53fe4615508be9f8a66a09be380c5b58">GetBackendVersion</a> ()=0</td></tr>
<tr class="memdesc:a53fe4615508be9f8a66a09be380c5b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">PVR add-ons client backend version.  <a href="#a53fe4615508be9f8a66a09be380c5b58">More...</a><br /></td></tr>
<tr class="separator:a53fe4615508be9f8a66a09be380c5b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ae7e428576f46113acbe95a0541137"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ae7ae7e428576f46113acbe95a0541137">GetBackendHostname</a> ()</td></tr>
<tr class="memdesc:ae7ae7e428576f46113acbe95a0541137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hostname of the pvr backend server.  <a href="#ae7ae7e428576f46113acbe95a0541137">More...</a><br /></td></tr>
<tr class="separator:ae7ae7e428576f46113acbe95a0541137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d0cfecdf208ebdd2c57e1bd25c1105"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a33d0cfecdf208ebdd2c57e1bd25c1105">GetConnectionString</a> ()=0</td></tr>
<tr class="memdesc:a33d0cfecdf208ebdd2c57e1bd25c1105"><td class="mdescLeft">&#160;</td><td class="mdescRight">PVR add-ons connection string of client.  <a href="#a33d0cfecdf208ebdd2c57e1bd25c1105">More...</a><br /></td></tr>
<tr class="separator:a33d0cfecdf208ebdd2c57e1bd25c1105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c300021dbc245db3bb63b723220cc9"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#aa3c300021dbc245db3bb63b723220cc9">GetDriveSpace</a> (long long &amp;total, long long &amp;used)</td></tr>
<tr class="memdesc:aa3c300021dbc245db3bb63b723220cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the disk space reported by the backend (if supported).  <a href="#aa3c300021dbc245db3bb63b723220cc9">More...</a><br /></td></tr>
<tr class="separator:aa3c300021dbc245db3bb63b723220cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe31a35b15f56bcacb22298c3f34bc21"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#abe31a35b15f56bcacb22298c3f34bc21">MenuHook</a> (const <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k.html">PVR_MENUHOOK</a> &amp;menuhook, const <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k___d_a_t_a.html">PVR_MENUHOOK_DATA</a> &amp;item)</td></tr>
<tr class="memdesc:abe31a35b15f56bcacb22298c3f34bc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call one of the menu hooks (if supported).  <a href="#abe31a35b15f56bcacb22298c3f34bc21">More...</a><br /></td></tr>
<tr class="separator:abe31a35b15f56bcacb22298c3f34bc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR channel group methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi is bSupportsChannelGroups is set to true. If a group or one of the group members changes after the initial import, or if a new one was added, then the add-on should call <a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a935da613c39f91145b6f230728bb1df0" title="Request Kodi to update it&#39;s list of channel groups. ">TriggerChannelGroupsUpdate()</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a1863221d2c36b1c00b4d49afe74ed18a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a1863221d2c36b1c00b4d49afe74ed18a">GetChannelGroupsAmount</a> ()</td></tr>
<tr class="memdesc:a1863221d2c36b1c00b4d49afe74ed18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total amount of channel groups on the backend if it supports channel groups.  <a href="#a1863221d2c36b1c00b4d49afe74ed18a">More...</a><br /></td></tr>
<tr class="separator:a1863221d2c36b1c00b4d49afe74ed18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9332c6c5b452bf554f6c35d78e3714ad"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a9332c6c5b452bf554f6c35d78e3714ad">GetChannelGroups</a> (bool radio, std::vector&lt; <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p.html">PVR_CHANNEL_GROUP</a> &gt; &amp;groups)</td></tr>
<tr class="memdesc:a9332c6c5b452bf554f6c35d78e3714ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the list of all channel groups from the backend if it supports channel groups.  <a href="#a9332c6c5b452bf554f6c35d78e3714ad">More...</a><br /></td></tr>
<tr class="separator:a9332c6c5b452bf554f6c35d78e3714ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871918c251aa05c7f677be887fee6b96"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a871918c251aa05c7f677be887fee6b96">GetChannelGroupMembers</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p.html">PVR_CHANNEL_GROUP</a> &amp;group, std::vector&lt; <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p___m_e_m_b_e_r.html">PVR_CHANNEL_GROUP_MEMBER</a> &gt; &amp;members)</td></tr>
<tr class="memdesc:a871918c251aa05c7f677be887fee6b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the list of all group members of a group from the backend if it supports channel groups.  <a href="#a871918c251aa05c7f677be887fee6b96">More...</a><br /></td></tr>
<tr class="separator:a871918c251aa05c7f677be887fee6b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR channel methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Either bSupportsTV or bSupportsRadio is required to be set to true. If a channel changes after the initial import, or if a new one was added, then the add-on should call <a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a0be8a63a1bde169779281dff66e50014" title="Request Kodi to update it&#39;s list of channels. ">TriggerChannelUpdate()</a> </dd></dl>
</div></td></tr>
<tr class="memitem:aba2b9e1367472248c67ed4112cbef89c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#aba2b9e1367472248c67ed4112cbef89c">GetChannelsAmount</a> ()=0</td></tr>
<tr class="memdesc:aba2b9e1367472248c67ed4112cbef89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get total amount of channels on the backend.  <a href="#aba2b9e1367472248c67ed4112cbef89c">More...</a><br /></td></tr>
<tr class="separator:aba2b9e1367472248c67ed4112cbef89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0310e0acf08e666c04ec45ae16f1f3f9"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a0310e0acf08e666c04ec45ae16f1f3f9">GetChannels</a> (bool bRadio, std::vector&lt; <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &gt; &amp;channels)</td></tr>
<tr class="memdesc:a0310e0acf08e666c04ec45ae16f1f3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the list of all channels from the backend.  <a href="#a0310e0acf08e666c04ec45ae16f1f3f9">More...</a><br /></td></tr>
<tr class="separator:a0310e0acf08e666c04ec45ae16f1f3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5b90d2b11864f8a884b2dae295183f"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#aca5b90d2b11864f8a884b2dae295183f">DeleteChannel</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="memdesc:aca5b90d2b11864f8a884b2dae295183f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a channel from the backend.  <a href="#aca5b90d2b11864f8a884b2dae295183f">More...</a><br /></td></tr>
<tr class="separator:aca5b90d2b11864f8a884b2dae295183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bce284f52c8ea14178ccc1e8540d977"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a9bce284f52c8ea14178ccc1e8540d977">RenameChannel</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="memdesc:a9bce284f52c8ea14178ccc1e8540d977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a channel on the backend.  <a href="#a9bce284f52c8ea14178ccc1e8540d977">More...</a><br /></td></tr>
<tr class="separator:a9bce284f52c8ea14178ccc1e8540d977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca88fcd1159a649eacc31f6084743c6"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a9ca88fcd1159a649eacc31f6084743c6">MoveChannel</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="memdesc:a9ca88fcd1159a649eacc31f6084743c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a channel to another channel number on the backend.  <a href="#a9ca88fcd1159a649eacc31f6084743c6">More...</a><br /></td></tr>
<tr class="separator:a9ca88fcd1159a649eacc31f6084743c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f9e538066139807b9b7a8b54bddb5c"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a59f9e538066139807b9b7a8b54bddb5c">OpenDialogChannelScan</a> ()</td></tr>
<tr class="memdesc:a59f9e538066139807b9b7a8b54bddb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show the channel scan dialog if this backend supports it.  <a href="#a59f9e538066139807b9b7a8b54bddb5c">More...</a><br /></td></tr>
<tr class="separator:a59f9e538066139807b9b7a8b54bddb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc201fcaeffe75955ec5217f2c6703b8"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#acc201fcaeffe75955ec5217f2c6703b8">OpenDialogChannelSettings</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="memdesc:acc201fcaeffe75955ec5217f2c6703b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show the channel settings dialog, if supported by the backend.  <a href="#acc201fcaeffe75955ec5217f2c6703b8">More...</a><br /></td></tr>
<tr class="separator:acc201fcaeffe75955ec5217f2c6703b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fb2e23bec988e628b7355dae1099f9"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ab1fb2e23bec988e628b7355dae1099f9">OpenDialogChannelAdd</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="memdesc:ab1fb2e23bec988e628b7355dae1099f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show the dialog to add a channel on the backend, if supported by the backend.  <a href="#ab1fb2e23bec988e628b7355dae1099f9">More...</a><br /></td></tr>
<tr class="separator:ab1fb2e23bec988e628b7355dae1099f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR EPG methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi if bSupportsEPG is set to true. </dd></dl>
</div></td></tr>
<tr class="memitem:ad7fffabecb8eee5b0ba41ab344cf6580"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ad7fffabecb8eee5b0ba41ab344cf6580">GetEPG</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel, time_t iStart, time_t iEnd, std::vector&lt; <a class="el" href="struct_e_p_g___t_a_g.html">EPG_TAG</a> &gt; &amp;epg)</td></tr>
<tr class="memdesc:ad7fffabecb8eee5b0ba41ab344cf6580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the EPG for a channel from the backend.  <a href="#ad7fffabecb8eee5b0ba41ab344cf6580">More...</a><br /></td></tr>
<tr class="separator:ad7fffabecb8eee5b0ba41ab344cf6580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c086e38e664d9889aef86481734878f"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a1c086e38e664d9889aef86481734878f">SetEPGTimeFrame</a> (int days)</td></tr>
<tr class="memdesc:a1c086e38e664d9889aef86481734878f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the client the time frame to use when notifying epg events back to Kodi.  <a href="#a1c086e38e664d9889aef86481734878f">More...</a><br /></td></tr>
<tr class="separator:a1c086e38e664d9889aef86481734878f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR recording methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi is bSupportsRecordings is set to true. If a recording changes after the initial import, or if a new one was added, then the add-on should call <a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a32558a6dec1bee47462379c7fb11dc1a" title="Request Kodi to update it&#39;s list of recordings. ">TriggerRecordingUpdate()</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a64185e2834b089d699104620b2358d53"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a64185e2834b089d699104620b2358d53">GetRecordingsAmount</a> (bool deleted)</td></tr>
<tr class="memdesc:a64185e2834b089d699104620b2358d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get the amount of usable or deleted recordings.  <a href="#a64185e2834b089d699104620b2358d53">More...</a><br /></td></tr>
<tr class="separator:a64185e2834b089d699104620b2358d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7152a7b836c5dd30abe485b83a89caea"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a7152a7b836c5dd30abe485b83a89caea">GetRecordings</a> (bool deleted, std::vector&lt; <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &gt; &amp;recording)</td></tr>
<tr class="memdesc:a7152a7b836c5dd30abe485b83a89caea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the list of all recordings from the backend, if supported.  <a href="#a7152a7b836c5dd30abe485b83a89caea">More...</a><br /></td></tr>
<tr class="separator:a7152a7b836c5dd30abe485b83a89caea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dca4e86e119a9189c72be0fe4b7bd7c"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a5dca4e86e119a9189c72be0fe4b7bd7c">DeleteRecording</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="memdesc:a5dca4e86e119a9189c72be0fe4b7bd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a recording on the backend.  <a href="#a5dca4e86e119a9189c72be0fe4b7bd7c">More...</a><br /></td></tr>
<tr class="separator:a5dca4e86e119a9189c72be0fe4b7bd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5446e0506474d8dd063ae497917d686"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ad5446e0506474d8dd063ae497917d686">UndeleteRecording</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="memdesc:ad5446e0506474d8dd063ae497917d686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undelete a recording on the backend.  <a href="#ad5446e0506474d8dd063ae497917d686">More...</a><br /></td></tr>
<tr class="separator:ad5446e0506474d8dd063ae497917d686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7efbd0f0094981538af0d61ca8f2f7f"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ac7efbd0f0094981538af0d61ca8f2f7f">DeleteAllRecordingsFromTrash</a> ()</td></tr>
<tr class="memdesc:ac7efbd0f0094981538af0d61ca8f2f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all recordings permanent which in the deleted folder on the backend.  <a href="#ac7efbd0f0094981538af0d61ca8f2f7f">More...</a><br /></td></tr>
<tr class="separator:ac7efbd0f0094981538af0d61ca8f2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b28167ada3d414385e3293ef88447b"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a95b28167ada3d414385e3293ef88447b">RenameRecording</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="memdesc:a95b28167ada3d414385e3293ef88447b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a recording on the backend.  <a href="#a95b28167ada3d414385e3293ef88447b">More...</a><br /></td></tr>
<tr class="separator:a95b28167ada3d414385e3293ef88447b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6904cb9ec7714c094115f20b20da8f8b"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a6904cb9ec7714c094115f20b20da8f8b">SetRecordingPlayCount</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording, int count)</td></tr>
<tr class="memdesc:a6904cb9ec7714c094115f20b20da8f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the play count of a recording on the backend.  <a href="#a6904cb9ec7714c094115f20b20da8f8b">More...</a><br /></td></tr>
<tr class="separator:a6904cb9ec7714c094115f20b20da8f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97879a88e08f8029f0c156d07b2bf74b"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a97879a88e08f8029f0c156d07b2bf74b">SetRecordingLastPlayedPosition</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording, int lastplayedposition)</td></tr>
<tr class="memdesc:a97879a88e08f8029f0c156d07b2bf74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the last watched position of a recording on the backend.  <a href="#a97879a88e08f8029f0c156d07b2bf74b">More...</a><br /></td></tr>
<tr class="separator:a97879a88e08f8029f0c156d07b2bf74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e79f3747e544333b4aee09aa37e7f6b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a2e79f3747e544333b4aee09aa37e7f6b">GetRecordingLastPlayedPosition</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="memdesc:a2e79f3747e544333b4aee09aa37e7f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the last watched position of a recording on the backend.  <a href="#a2e79f3747e544333b4aee09aa37e7f6b">More...</a><br /></td></tr>
<tr class="separator:a2e79f3747e544333b4aee09aa37e7f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88154bfb10c7ff5f73a2e4b0f70ad9e2"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a88154bfb10c7ff5f73a2e4b0f70ad9e2">GetRecordingEdl</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;, std::vector&lt; <a class="el" href="struct_p_v_r___e_d_l___e_n_t_r_y.html">PVR_EDL_ENTRY</a> &gt; &amp;edl)</td></tr>
<tr class="memdesc:a88154bfb10c7ff5f73a2e4b0f70ad9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the edit decision list (EDL) of a recording on the backend.  <a href="#a88154bfb10c7ff5f73a2e4b0f70ad9e2">More...</a><br /></td></tr>
<tr class="separator:a88154bfb10c7ff5f73a2e4b0f70ad9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR timer methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi is bSupportsTimers is set to true. If a timer changes after the initial import, or if a new one was added, then the add-on should call <a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a7a28ab2aa9e2f3191c2d6281cdc680ee" title="Request Kodi to update it&#39;s list of timers. ">TriggerTimerUpdate()</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a04a8faac3d7ee49b8eed0d989bb487e6"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a04a8faac3d7ee49b8eed0d989bb487e6">GetTimerTypes</a> (std::vector&lt; <a class="el" href="struct_p_v_r___t_i_m_e_r___t_y_p_e.html">PVR_TIMER_TYPE</a> &gt; &amp;types)</td></tr>
<tr class="memdesc:a04a8faac3d7ee49b8eed0d989bb487e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the timer types supported by the backend.  <a href="#a04a8faac3d7ee49b8eed0d989bb487e6">More...</a><br /></td></tr>
<tr class="separator:a04a8faac3d7ee49b8eed0d989bb487e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90276466a1a0ade0a9610466bb921b7a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a90276466a1a0ade0a9610466bb921b7a">GetTimersAmount</a> ()</td></tr>
<tr class="memdesc:a90276466a1a0ade0a9610466bb921b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get the complete amount of timers present on backend.  <a href="#a90276466a1a0ade0a9610466bb921b7a">More...</a><br /></td></tr>
<tr class="separator:a90276466a1a0ade0a9610466bb921b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91168fb099d782fbe1ba5dd1d100d900"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a91168fb099d782fbe1ba5dd1d100d900">GetTimers</a> (std::vector&lt; <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &gt; &amp;timers)</td></tr>
<tr class="memdesc:a91168fb099d782fbe1ba5dd1d100d900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the list of all timers from the backend if supported.  <a href="#a91168fb099d782fbe1ba5dd1d100d900">More...</a><br /></td></tr>
<tr class="separator:a91168fb099d782fbe1ba5dd1d100d900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6aebe4d427ffe09282b83ac1220491"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#afd6aebe4d427ffe09282b83ac1220491">AddTimer</a> (const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;timer)</td></tr>
<tr class="memdesc:afd6aebe4d427ffe09282b83ac1220491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a timer on the backend.  <a href="#afd6aebe4d427ffe09282b83ac1220491">More...</a><br /></td></tr>
<tr class="separator:afd6aebe4d427ffe09282b83ac1220491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af525481ac54425bc9039a631c3931932"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#af525481ac54425bc9039a631c3931932">DeleteTimer</a> (const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;timer, bool forceDelete)</td></tr>
<tr class="memdesc:af525481ac54425bc9039a631c3931932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a timer on the backend.  <a href="#af525481ac54425bc9039a631c3931932">More...</a><br /></td></tr>
<tr class="separator:af525481ac54425bc9039a631c3931932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb079f099725c0caeec2a8a8d9fc392"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a2fb079f099725c0caeec2a8a8d9fc392">UpdateTimer</a> (const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;timer)</td></tr>
<tr class="memdesc:a2fb079f099725c0caeec2a8a8d9fc392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the timer information on the backend.  <a href="#a2fb079f099725c0caeec2a8a8d9fc392">More...</a><br /></td></tr>
<tr class="separator:a2fb079f099725c0caeec2a8a8d9fc392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR live stream methods, used to open and close a stream to a channel, and optionally perform read operations on the stream</div></td></tr>
<tr class="memitem:a21cfc432638fbb472fdb028d4537b06b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a21cfc432638fbb472fdb028d4537b06b">OpenLiveStream</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="memdesc:a21cfc432638fbb472fdb028d4537b06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a live stream on the backend.  <a href="#a21cfc432638fbb472fdb028d4537b06b">More...</a><br /></td></tr>
<tr class="separator:a21cfc432638fbb472fdb028d4537b06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bba75e53a1dcb5f50a62ee2b4d2d76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a32bba75e53a1dcb5f50a62ee2b4d2d76">CloseLiveStream</a> ()</td></tr>
<tr class="memdesc:a32bba75e53a1dcb5f50a62ee2b4d2d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an open live stream.  <a href="#a32bba75e53a1dcb5f50a62ee2b4d2d76">More...</a><br /></td></tr>
<tr class="separator:a32bba75e53a1dcb5f50a62ee2b4d2d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4384e7b0a9c8f8b06ee1b7e015b193"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a8b4384e7b0a9c8f8b06ee1b7e015b193">ReadLiveStream</a> (unsigned char *buffer, unsigned int bufferSize)</td></tr>
<tr class="memdesc:a8b4384e7b0a9c8f8b06ee1b7e015b193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from an open live stream.  <a href="#a8b4384e7b0a9c8f8b06ee1b7e015b193">More...</a><br /></td></tr>
<tr class="separator:a8b4384e7b0a9c8f8b06ee1b7e015b193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec0ef45efad41d707d92017146f0caa"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a0ec0ef45efad41d707d92017146f0caa">SeekLiveStream</a> (long long position, int whence=SEEK_SET)</td></tr>
<tr class="memdesc:a0ec0ef45efad41d707d92017146f0caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek in a live stream on a backend that supports timeshifting.  <a href="#a0ec0ef45efad41d707d92017146f0caa">More...</a><br /></td></tr>
<tr class="separator:a0ec0ef45efad41d707d92017146f0caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e500b96216af2666b6169e709f2ac09"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a1e500b96216af2666b6169e709f2ac09">PositionLiveStream</a> ()</td></tr>
<tr class="memdesc:a1e500b96216af2666b6169e709f2ac09"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get position in the stream that's currently being read.  <a href="#a1e500b96216af2666b6169e709f2ac09">More...</a><br /></td></tr>
<tr class="separator:a1e500b96216af2666b6169e709f2ac09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f782d7543efcc16e168d2af7589183"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ae6f782d7543efcc16e168d2af7589183">LengthLiveStream</a> ()</td></tr>
<tr class="memdesc:ae6f782d7543efcc16e168d2af7589183"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get total length of the stream that's currently being read.  <a href="#ae6f782d7543efcc16e168d2af7589183">More...</a><br /></td></tr>
<tr class="separator:ae6f782d7543efcc16e168d2af7589183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf10d6e1304b3350cf3a3b95e5f402a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a5cf10d6e1304b3350cf3a3b95e5f402a">SwitchChannel</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="memdesc:a5cf10d6e1304b3350cf3a3b95e5f402a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to another channel. Only to be called when a live stream has already been opened.  <a href="#a5cf10d6e1304b3350cf3a3b95e5f402a">More...</a><br /></td></tr>
<tr class="separator:a5cf10d6e1304b3350cf3a3b95e5f402a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca92fdd76948e4e18c77b30e57e7a64f"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#aca92fdd76948e4e18c77b30e57e7a64f">GetChannelSwitchDelay</a> (void)</td></tr>
<tr class="memdesc:aca92fdd76948e4e18c77b30e57e7a64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay to use when using switching channels for add-ons not providing an input stream.  <a href="#aca92fdd76948e4e18c77b30e57e7a64f">More...</a><br /></td></tr>
<tr class="separator:aca92fdd76948e4e18c77b30e57e7a64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4480787e192e8201532c6e7e26afb2aa"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a4480787e192e8201532c6e7e26afb2aa">SignalStatus</a> (<a class="el" href="struct_p_v_r___s_i_g_n_a_l___s_t_a_t_u_s.html">PVR_SIGNAL_STATUS</a> &amp;signalStatus)</td></tr>
<tr class="memdesc:a4480787e192e8201532c6e7e26afb2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the signal status of the stream that's currently open.  <a href="#a4480787e192e8201532c6e7e26afb2aa">More...</a><br /></td></tr>
<tr class="separator:a4480787e192e8201532c6e7e26afb2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aacb4500896b500cb9ebcd37125b41d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a4aacb4500896b500cb9ebcd37125b41d">GetLiveStreamURL</a> (const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="memdesc:a4aacb4500896b500cb9ebcd37125b41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stream URL for a channel from the backend. Used by the MediaPortal add-on.  <a href="#a4aacb4500896b500cb9ebcd37125b41d">More...</a><br /></td></tr>
<tr class="separator:a4aacb4500896b500cb9ebcd37125b41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fbd75122fc3ab90ee68029b036ba2c"><td class="memItemLeft" align="right" valign="top">virtual PVR_ERROR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a96fbd75122fc3ab90ee68029b036ba2c">GetStreamProperties</a> (<a class="el" href="struct_p_v_r___s_t_r_e_a_m___p_r_o_p_e_r_t_i_e_s.html">PVR_STREAM_PROPERTIES</a> &amp;properties)</td></tr>
<tr class="memdesc:a96fbd75122fc3ab90ee68029b036ba2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stream properties of the stream that's currently being read.  <a href="#a96fbd75122fc3ab90ee68029b036ba2c">More...</a><br /></td></tr>
<tr class="separator:a96fbd75122fc3ab90ee68029b036ba2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR recording stream methods, used to open and close a stream to a recording, and perform read operations on the stream.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>This will only be used if the backend doesn't provide a direct URL in the recording tag. </dd></dl>
</div></td></tr>
<tr class="memitem:a64dec46d224b30e8f23150274f6ce162"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a64dec46d224b30e8f23150274f6ce162">OpenRecordedStream</a> (const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="memdesc:a64dec46d224b30e8f23150274f6ce162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a stream to a recording on the backend.  <a href="#a64dec46d224b30e8f23150274f6ce162">More...</a><br /></td></tr>
<tr class="separator:a64dec46d224b30e8f23150274f6ce162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821acbad9c64aadf4c39d3719360cfa9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a821acbad9c64aadf4c39d3719360cfa9">CloseRecordedStream</a> ()</td></tr>
<tr class="memdesc:a821acbad9c64aadf4c39d3719360cfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an open stream from a recording.  <a href="#a821acbad9c64aadf4c39d3719360cfa9">More...</a><br /></td></tr>
<tr class="separator:a821acbad9c64aadf4c39d3719360cfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b863bb3de7f0420470ad80b7d8601d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ac3b863bb3de7f0420470ad80b7d8601d">ReadRecordedStream</a> (unsigned char *buffer, unsigned int bufferSize)</td></tr>
<tr class="memdesc:ac3b863bb3de7f0420470ad80b7d8601d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a recording.  <a href="#ac3b863bb3de7f0420470ad80b7d8601d">More...</a><br /></td></tr>
<tr class="separator:ac3b863bb3de7f0420470ad80b7d8601d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46e05f4fb6acf765772e0c633200fb3"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ac46e05f4fb6acf765772e0c633200fb3">SeekRecordedStream</a> (long long iPosition, int iWhence=SEEK_SET)</td></tr>
<tr class="memdesc:ac46e05f4fb6acf765772e0c633200fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek in a recorded stream.  <a href="#ac46e05f4fb6acf765772e0c633200fb3">More...</a><br /></td></tr>
<tr class="separator:ac46e05f4fb6acf765772e0c633200fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0cb11fe6eb9018a9f41476b53e96eb"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#acc0cb11fe6eb9018a9f41476b53e96eb">PositionRecordedStream</a> ()</td></tr>
<tr class="memdesc:acc0cb11fe6eb9018a9f41476b53e96eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get position in the stream that's currently being read.  <a href="#acc0cb11fe6eb9018a9f41476b53e96eb">More...</a><br /></td></tr>
<tr class="separator:acc0cb11fe6eb9018a9f41476b53e96eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddbf9cbfa657fb7a8b0d3c2f6d1139d"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a0ddbf9cbfa657fb7a8b0d3c2f6d1139d">LengthRecordedStream</a> ()</td></tr>
<tr class="memdesc:a0ddbf9cbfa657fb7a8b0d3c2f6d1139d"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get total length of the stream that's currently being read.  <a href="#a0ddbf9cbfa657fb7a8b0d3c2f6d1139d">More...</a><br /></td></tr>
<tr class="separator:a0ddbf9cbfa657fb7a8b0d3c2f6d1139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR demultiplexer methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi is bHandlesDemuxing is set to true. </dd></dl>
</div></td></tr>
<tr class="memitem:a4e1a9156a48ad4536be348fb698bc996"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a4e1a9156a48ad4536be348fb698bc996">DemuxReset</a> ()</td></tr>
<tr class="memdesc:a4e1a9156a48ad4536be348fb698bc996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the demultiplexer in the add-on.  <a href="#a4e1a9156a48ad4536be348fb698bc996">More...</a><br /></td></tr>
<tr class="separator:a4e1a9156a48ad4536be348fb698bc996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba868e65400538851ce66f19d901191"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a9ba868e65400538851ce66f19d901191">DemuxAbort</a> ()</td></tr>
<tr class="memdesc:a9ba868e65400538851ce66f19d901191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the demultiplexer thread in the add-on.  <a href="#a9ba868e65400538851ce66f19d901191">More...</a><br /></td></tr>
<tr class="separator:a9ba868e65400538851ce66f19d901191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae5d8cdca2d570c01adcf7c7b5e8f75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#aaae5d8cdca2d570c01adcf7c7b5e8f75">DemuxFlush</a> ()</td></tr>
<tr class="memdesc:aaae5d8cdca2d570c01adcf7c7b5e8f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush all data that's currently in the demultiplexer buffer in the add-on.  <a href="#aaae5d8cdca2d570c01adcf7c7b5e8f75">More...</a><br /></td></tr>
<tr class="separator:aaae5d8cdca2d570c01adcf7c7b5e8f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c257fded197ec1a78bf3c9d9f9fa78"><td class="memItemLeft" align="right" valign="top">virtual DemuxPacket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#ad2c257fded197ec1a78bf3c9d9f9fa78">DemuxRead</a> ()</td></tr>
<tr class="memdesc:ad2c257fded197ec1a78bf3c9d9f9fa78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next packet from the demultiplexer, if there is one.  <a href="#ad2c257fded197ec1a78bf3c9d9f9fa78">More...</a><br /></td></tr>
<tr class="separator:ad2c257fded197ec1a78bf3c9d9f9fa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a89343289dac30a826b80aaafb104f411"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html">CAddon</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>The from Kodi given instance given be add-on CreateInstance call with instance id ADDON_INSTANCE_PVR. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7ae98b714d1be647177c75cdc8657455"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetCapabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html">PVR_ADDON_CAPABILITIES</a> &amp;&#160;</td>
          <td class="paramname"><em>capabilities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of features that this add-on provides. </p>
<p>Called by Kodi to query the add-on's capabilities.</p>
<p>Used to check which options should be presented in the UI, which methods to call, etc.</p>
<p>All capabilities that the add-on supports should be set to true. As default them set from Kodi to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">capabilities</td><td>The add-on's capabilities, see <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html" title="PVR add-on capabilities. All capabilities are set to &quot;false&quot; as default. If a capabilty is set to tru...">PVR_ADDON_CAPABILITIES</a> for detailed informations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d08c3fcded44c002c5f7af63f2c0dfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* GetBackendName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PVR add-ons backend name. </p>
<dl class="section return"><dt>Returns</dt><dd>The name reported by the backend that will be displayed in the UI.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a53fe4615508be9f8a66a09be380c5b58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string GetBackendVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PVR add-ons client backend version. </p>
<dl class="section return"><dt>Returns</dt><dd>The version string reported by the backend that will be displayed in the UI.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7ae7e428576f46113acbe95a0541137"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string GetBackendHostname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the hostname of the pvr backend server. </p>
<dl class="section return"><dt>Returns</dt><dd>hostname as ip address or alias.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If backend does not utilize a server ignore this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a33d0cfecdf208ebdd2c57e1bd25c1105"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string GetConnectionString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PVR add-ons connection string of client. </p>
<dl class="section return"><dt>Returns</dt><dd>The connection string reported by the backend that will be displayed in the UI.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3c300021dbc245db3bb63b723220cc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetDriveSpace </td>
          <td>(</td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the disk space reported by the backend (if supported). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">total</td><td>The total disk space in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">used</td><td>The used disk space in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the drive space has been fetched successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional. </dd></dl>

</div>
</div>
<a class="anchor" id="abe31a35b15f56bcacb22298c3f34bc21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR MenuHook </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k.html">PVR_MENUHOOK</a> &amp;&#160;</td>
          <td class="paramname"><em>menuhook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k___d_a_t_a.html">PVR_MENUHOOK_DATA</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call one of the menu hooks (if supported). </p>
<p>Supported <a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k.html" title="Menu hooks that are available in the context menus while playing a stream via this add-on...">PVR_MENUHOOK</a> instances have to be added in ADDON_Create(), by calling <a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a45884e189fad76597699caa992574bef" title="Add or replace a menu hook for the context menu for this add-on. ">AddMenuHook()</a> on the callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">menuhook</td><td>The hook to call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>The selected item for which the hook was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the hook was called successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional. </dd></dl>

</div>
</div>
<a class="anchor" id="a1863221d2c36b1c00b4d49afe74ed18a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GetChannelGroupsAmount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total amount of channel groups on the backend if it supports channel groups. </p>
<dl class="section return"><dt>Returns</dt><dd>The amount of channels, or -1 on error.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a8e4d51f8fa63513d7311e835b65d584a" title="true if this add-on supports channel groups ">PVR_ADDON_CAPABILITIES::bSupportsChannelGroups</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a9332c6c5b452bf554f6c35d78e3714ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetChannelGroups </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>radio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p.html">PVR_CHANNEL_GROUP</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the list of all channel groups from the backend if it supports channel groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radio</td><td>True to get the radio channel groups, false to get the TV channel groups. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">groups</td><td>List to store availanle channel groups withe the</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a8e4d51f8fa63513d7311e835b65d584a" title="true if this add-on supports channel groups ">PVR_ADDON_CAPABILITIES::bSupportsChannelGroups</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a871918c251aa05c7f677be887fee6b96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetChannelGroupMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p.html">PVR_CHANNEL_GROUP</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p___m_e_m_b_e_r.html">PVR_CHANNEL_GROUP_MEMBER</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the list of all group members of a group from the backend if it supports channel groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>The group to get the members for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">members</td><td>list of all group members of group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a8e4d51f8fa63513d7311e835b65d584a" title="true if this add-on supports channel groups ">PVR_ADDON_CAPABILITIES::bSupportsChannelGroups</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="aba2b9e1367472248c67ed4112cbef89c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GetChannelsAmount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To get total amount of channels on the backend. </p>
<dl class="section return"><dt>Returns</dt><dd>The total amount of channels on the backend, or -1 on error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a class="anchor" id="a0310e0acf08e666c04ec45ae16f1f3f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetChannels </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRadio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the list of all channels from the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bRadio</td><td>True to get the radio channels, false to get the TV channels. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">channels</td><td>list to add available channls defined with the <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html" title="Representation of a TV or radio channel. ">PVR_CHANNEL</a> structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a081d8e4e19a1b04eb19569f2f807eccf" title="true if this add-on provides TV channels ">PVR_ADDON_CAPABILITIES::bSupportsTV</a> is set to true, a valid result set needs to be provided for bRadio = false.<br />
If <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#ac56dba1378272b8c53c10876135db0fe" title="true if this add-on supports radio channels ">PVR_ADDON_CAPABILITIES::bSupportsRadio</a> is set to true, a valid result set needs to be provided for bRadio = true.<br />
At least one of these two must provide a valid result set. </dd></dl>

</div>
</div>
<a class="anchor" id="aca5b90d2b11864f8a884b2dae295183f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR DeleteChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a channel from the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The channel to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been deleted successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a0435c9bf30ea1b1395b71054d3682efc" title="true if this add-on supports the following functions: DeleteChannel, RenameChannel, MoveChannel, DialogChannelSettings and DialogAddChannel ">PVR_ADDON_CAPABILITIES::bSupportsChannelSettings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bce284f52c8ea14178ccc1e8540d977"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR RenameChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename a channel on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The channel to rename, containing the new channel name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been renamed successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a0435c9bf30ea1b1395b71054d3682efc" title="true if this add-on supports the following functions: DeleteChannel, RenameChannel, MoveChannel, DialogChannelSettings and DialogAddChannel ">PVR_ADDON_CAPABILITIES::bSupportsChannelSettings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ca88fcd1159a649eacc31f6084743c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR MoveChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move a channel to another channel number on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The channel to move, containing the new channel number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been moved successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsChannelSettings is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a59f9e538066139807b9b7a8b54bddb5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR OpenDialogChannelScan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Show the channel scan dialog if this backend supports it. </p>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the dialog was displayed successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a98a9e9a76ed7fb3a7e750e20235303f3" title="true if this add-on support scanning for new channels on the backend ">PVR_ADDON_CAPABILITIES::bSupportsChannelScan</a> is set to true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>see kodi::gui about related parts </dd></dl>

</div>
</div>
<a class="anchor" id="acc201fcaeffe75955ec5217f2c6703b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR OpenDialogChannelSettings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Show the channel settings dialog, if supported by the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The channel to show the dialog for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the dialog has been displayed successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a0435c9bf30ea1b1395b71054d3682efc" title="true if this add-on supports the following functions: DeleteChannel, RenameChannel, MoveChannel, DialogChannelSettings and DialogAddChannel ">PVR_ADDON_CAPABILITIES::bSupportsChannelSettings</a> is set to true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>see kodi::gui about related parts </dd></dl>

</div>
</div>
<a class="anchor" id="ab1fb2e23bec988e628b7355dae1099f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR OpenDialogChannelAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Show the dialog to add a channel on the backend, if supported by the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The channel to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been added successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a0435c9bf30ea1b1395b71054d3682efc" title="true if this add-on supports the following functions: DeleteChannel, RenameChannel, MoveChannel, DialogChannelSettings and DialogAddChannel ">PVR_ADDON_CAPABILITIES::bSupportsChannelSettings</a> is set to true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>see kodi::gui about related parts </dd></dl>

</div>
</div>
<a class="anchor" id="ad7fffabecb8eee5b0ba41ab344cf6580"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetEPG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>iStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>iEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_e_p_g___t_a_g.html">EPG_TAG</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>epg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the EPG for a channel from the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The channel to get the EPG table for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Get events after this time (UTC). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>Get events before this time (UTC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the table has been fetched successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a9e1cc84853679832105123c3948dc4d5" title="true if the add-on provides EPG information ">PVR_ADDON_CAPABILITIES::bSupportsEPG</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c086e38e664d9889aef86481734878f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR SetEPGTimeFrame </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>days</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the client the time frame to use when notifying epg events back to Kodi. </p>
<p>The client might push epg events asynchronously to Kodi using the callback function EpgEventStateChange. To be able to only push events that are actually of interest for Kodi, client needs to know about the epg time frame Kodi uses. Kodi supplies the current epg time frame value in <a class="el" href="struct_p_v_r___p_r_o_p_e_r_t_i_e_s.html#ab3ae06bd7446dcc2bff00cc93a6f68cd" title="if &gt; EPG_TIMEFRAME_UNLIMITED, in async epg mode, deliver only events in the range from &#39;end time &gt; no...">PVR_PROPERTIES.iEpgMaxDays</a> when creating the addon and calls SetEPGTimeFrame later whenever Kodi's epg time frame value changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">days</td><td>number of days from "now". EPG_TIMEFRAME_UNLIMITED means that Kodi is interested in all epg events, regardless of event times. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if new value was successfully set. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a9e1cc84853679832105123c3948dc4d5" title="true if the add-on provides EPG information ">PVR_ADDON_CAPABILITIES::bSupportsEPG</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a64185e2834b089d699104620b2358d53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GetRecordingsAmount </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To get the amount of usable or deleted recordings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deleted</td><td>if set return deleted recording (called if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a2f249ff14666a73871ea11c9cd07a8f9" title="true if this add-on supports undelete of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordingsUndelete</a> set to true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total amount of recordings on the backend or -1 on error.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a7152a7b836c5dd30abe485b83a89caea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetRecordings </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>recording</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the list of all recordings from the backend, if supported. </p>
<p>Recording entries are added to Kodi by insert them to vector recording.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deleted</td><td>if set return deleted recording (called if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a2f249ff14666a73871ea11c9cd07a8f9" title="true if this add-on supports undelete of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordingsUndelete</a> set to true) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recording</td><td>the vector list where available recordings becomes inserted with the <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html" title="Representation of a recording. ">PVR_RECORDING</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recordings have been fetched successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dca4e86e119a9189c72be0fe4b7bd7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR DeleteRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a recording on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recording</td><td>The recording to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording has been deleted successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5446e0506474d8dd063ae497917d686"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR UndeleteRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Undelete a recording on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recording</td><td>The recording to undelete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording has been undeleted successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7efbd0f0094981538af0d61ca8f2f7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR DeleteAllRecordingsFromTrash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all recordings permanent which in the deleted folder on the backend. </p>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recordings has been deleted successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a2f249ff14666a73871ea11c9cd07a8f9" title="true if this add-on supports undelete of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordingsUndelete</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a95b28167ada3d414385e3293ef88447b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR RenameRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename a recording on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recording</td><td>The recording to rename, containing the new name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording has been renamed successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a6904cb9ec7714c094115f20b20da8f8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR SetRecordingPlayCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the play count of a recording on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recording</td><td>The recording to change the play count. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Play count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording's play count has been set successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a97879a88e08f8029f0c156d07b2bf74b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR SetRecordingLastPlayedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lastplayedposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the last watched position of a recording on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recording</td><td>The recording. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The last watched position in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the position has been stored successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e79f3747e544333b4aee09aa37e7f6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GetRecordingLastPlayedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the last watched position of a recording on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recording</td><td>The recording. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last watched position in seconds or -1 on error</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a88154bfb10c7ff5f73a2e4b0f70ad9e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetRecordingEdl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_p_v_r___e_d_l___e_n_t_r_y.html">PVR_EDL_ENTRY</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the edit decision list (EDL) of a recording on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recording</td><td>The recording. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edl</td><td>The function has to write the EDL list (defined as struct <a class="el" href="struct_p_v_r___e_d_l___e_n_t_r_y.html">PVR_EDL_ENTRY</a>) into this array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the EDL was successfully read. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a04a8faac3d7ee49b8eed0d989bb487e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetTimerTypes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_p_v_r___t_i_m_e_r___t_y_p_e.html">PVR_TIMER_TYPE</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the timer types supported by the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types[out]</td><td>The function has to write the definition of the supported timer types into this array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the types were successfully written to the array. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a400c1c7be9832ea40324ba02b68dd973" title="true if this add-on supports the creation and editing of timers ">PVR_ADDON_CAPABILITIES::bSupportsTimers</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a90276466a1a0ade0a9610466bb921b7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GetTimersAmount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To get the complete amount of timers present on backend. </p>
<dl class="section return"><dt>Returns</dt><dd>The total amount of timers on the backend or -1 on error.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a400c1c7be9832ea40324ba02b68dd973" title="true if this add-on supports the creation and editing of timers ">PVR_ADDON_CAPABILITIES::bSupportsTimers</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a91168fb099d782fbe1ba5dd1d100d900"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetTimers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>timers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the list of all timers from the backend if supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timers[out]</td><td>Vector list to store available timers defined with <a class="el" href="struct_p_v_r___t_i_m_e_r.html" title="Representation of a timer event. ">PVR_TIMER</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a400c1c7be9832ea40324ba02b68dd973" title="true if this add-on supports the creation and editing of timers ">PVR_ADDON_CAPABILITIES::bSupportsTimers</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="afd6aebe4d427ffe09282b83ac1220491"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR AddTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a timer on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>The timer to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the timer has been added successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a400c1c7be9832ea40324ba02b68dd973" title="true if this add-on supports the creation and editing of timers ">PVR_ADDON_CAPABILITIES::bSupportsTimers</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="af525481ac54425bc9039a631c3931932"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR DeleteTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceDelete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a timer on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>The timer to delete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceDelete</td><td>Set to true to delete a timer that is currently recording a program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the timer has been deleted successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a400c1c7be9832ea40324ba02b68dd973" title="true if this add-on supports the creation and editing of timers ">PVR_ADDON_CAPABILITIES::bSupportsTimers</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fb079f099725c0caeec2a8a8d9fc392"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR UpdateTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the timer information on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>The timer to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the timer has been updated successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a400c1c7be9832ea40324ba02b68dd973" title="true if this add-on supports the creation and editing of timers ">PVR_ADDON_CAPABILITIES::bSupportsTimers</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a21cfc432638fbb472fdb028d4537b06b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OpenLiveStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a live stream on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The channel to stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has been opened successfully, false otherwise.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> or <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa0a130028e1cda5c3f8e9fb13fbc7ac7" title="true if this add-on demultiplexes packets. ">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a32bba75e53a1dcb5f50a62ee2b4d2d76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CloseLiveStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close an open live stream. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> or <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa0a130028e1cda5c3f8e9fb13fbc7ac7" title="true if this add-on demultiplexes packets. ">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b4384e7b0a9c8f8b06ee1b7e015b193"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ReadLiveStream </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from an open live stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The amount of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of bytes that were actually read from the stream.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ec0ef45efad41d707d92017146f0caa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long SeekLiveStream </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em> = <code>SEEK_SET</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek in a live stream on a backend that supports timeshifting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position to seek to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whence</td><td>[optional] offset relative to You can set the value of whence to one of three things: <table class="doxtable">
<tr>
<th align="center">Value </th><th align="center">int </th><th align="left">Description  </th></tr>
<tr>
<td align="center">SEEK_SET </td><td align="center">0 </td><td align="left">position is relative to the beginning of the file. This is probably what you had in mind anyway, and is the most commonly used value for whence. </td></tr>
<tr>
<td align="center">SEEK_CUR </td><td align="center">1 </td><td align="left">position is relative to the current file pointer position. So, in effect, you can say, "Move to my current position plus 30 bytes," or, "move to my current position minus 20 bytes." </td></tr>
<tr>
<td align="center">SEEK_END </td><td align="center">2 </td><td align="left">position is relative to the end of the file. Just like SEEK_SET except from the other end of the file. Be sure to use negative values for offset if you want to back up from the end of the file, instead of going past the end into oblivion. </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the resulting offset location as measured in bytes from the beginning of the stream. On error, the value -1 is returned. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e500b96216af2666b6169e709f2ac09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long PositionLiveStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To get position in the stream that's currently being read. </p>
<dl class="section return"><dt>Returns</dt><dd>The position in the stream that's currently being read.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6f782d7543efcc16e168d2af7589183"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long LengthLiveStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To get total length of the stream that's currently being read. </p>
<dl class="section return"><dt>Returns</dt><dd>The total length of the stream that's currently being read.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf10d6e1304b3350cf3a3b95e5f402a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SwitchChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch to another channel. Only to be called when a live stream has already been opened. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The channel to switch to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the switch was successful, false otherwise.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> or <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa0a130028e1cda5c3f8e9fb13fbc7ac7" title="true if this add-on demultiplexes packets. ">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="aca92fdd76948e4e18c77b30e57e7a64f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int GetChannelSwitchDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delay to use when using switching channels for add-ons not providing an input stream. </p>
<p>If the add-on does provide an input stream, then this method will not be called.</p>
<p>Those add-ons can do that in <a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a21cfc432638fbb472fdb028d4537b06b" title="Open a live stream on the backend. ">OpenLiveStream()</a> if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>The delay in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a4480787e192e8201532c6e7e26afb2aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR SignalStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_v_r___s_i_g_n_a_l___s_t_a_t_u_s.html">PVR_SIGNAL_STATUS</a> &amp;&#160;</td>
          <td class="paramname"><em>signalStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the signal status of the stream that's currently open. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">signalStatus</td><td>The signal status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the signal status has been read successfully, false otherwise.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> or <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa0a130028e1cda5c3f8e9fb13fbc7ac7" title="true if this add-on demultiplexes packets. ">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a4aacb4500896b500cb9ebcd37125b41d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string GetLiveStreamURL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stream URL for a channel from the backend. Used by the MediaPortal add-on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">channel</td><td>The channel to get the stream URL for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested URL.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a96fbd75122fc3ab90ee68029b036ba2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVR_ERROR GetStreamProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_v_r___s_t_r_e_a_m___p_r_o_p_e_r_t_i_e_s.html">PVR_STREAM_PROPERTIES</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stream properties of the stream that's currently being read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">properties</td><td>The properties of the currently playing stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the properties have been fetched successfully. See PVR_ERROR for all possible values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a359e8015ac7906c2088fe0ecb3ec648f" title="true if this add-on provides an input stream. false if XBMC handles the stream. ">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> or <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa0a130028e1cda5c3f8e9fb13fbc7ac7" title="true if this add-on demultiplexes packets. ">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a64dec46d224b30e8f23150274f6ce162"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OpenRecordedStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a stream to a recording on the backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recording</td><td>The recording to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has been opened successfully, false otherwise.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a821acbad9c64aadf4c39d3719360cfa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CloseRecordedStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close an open stream from a recording. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3b863bb3de7f0420470ad80b7d8601d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ReadRecordedStream </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a recording. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iBufferSize</td><td>The amount of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of bytes that were actually read from the stream.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true, but required if <a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html#a64dec46d224b30e8f23150274f6ce162" title="Open a stream to a recording on the backend. ">OpenRecordedStream()</a> is implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="ac46e05f4fb6acf765772e0c633200fb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long SeekRecordedStream </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>iPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWhence</em> = <code>SEEK_SET</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek in a recorded stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iPosition</td><td>The position to seek to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iWhence</td><td>? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new position.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="acc0cb11fe6eb9018a9f41476b53e96eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long PositionRecordedStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To get position in the stream that's currently being read. </p>
<dl class="section return"><dt>Returns</dt><dd>The position in the stream that's currently being read.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ddbf9cbfa657fb7a8b0d3c2f6d1139d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long LengthRecordedStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To get total length of the stream that's currently being read. </p>
<dl class="section return"><dt>Returns</dt><dd>The total length of the stream that's currently being read.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a748e782ac4547cab51312991fa8c190e" title="true if this add-on supports playback of recordings stored on the backend ">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e1a9156a48ad4536be348fb698bc996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DemuxReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the demultiplexer in the add-on. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa0a130028e1cda5c3f8e9fb13fbc7ac7" title="true if this add-on demultiplexes packets. ">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ba868e65400538851ce66f19d901191"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DemuxAbort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abort the demultiplexer thread in the add-on. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa0a130028e1cda5c3f8e9fb13fbc7ac7" title="true if this add-on demultiplexes packets. ">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="aaae5d8cdca2d570c01adcf7c7b5e8f75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DemuxFlush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush all data that's currently in the demultiplexer buffer in the add-on. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa0a130028e1cda5c3f8e9fb13fbc7ac7" title="true if this add-on demultiplexes packets. ">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2c257fded197ec1a78bf3c9d9f9fa78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DemuxPacket* DemuxRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next packet from the demultiplexer, if there is one. </p>
<dl class="section return"><dt>Returns</dt><dd>The next packet.<br />
 If there is no next packet, then the add-on should return the packet created by calling AllocateDemuxPacket(0) on the callback. If the stream changed and Kodi's player needs to be reinitialised, then, the add-on should call AllocateDemuxPacket(0) on the callback, and set the streamid to DMX_SPECIALID_STREAMCHANGE and return the value.<br />
 The add-on should return nullptr if an error occured.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa0a130028e1cda5c3f8e9fb13fbc7ac7" title="true if this add-on demultiplexes packets. ">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. </dd></dl>

</div>
</div>
<a class="anchor" id="a86e12689cdfcd579b9e5d360c1b5aeff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CanPauseStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the backend support pausing the currently playing stream. </p>
<p>This will enable/disable the pause button in Kodi based on the return value</p>
<dl class="section return"><dt>Returns</dt><dd>false if the PVR addon/backend does not support pausing, true if possible </dd></dl>

</div>
</div>
<a class="anchor" id="afd8b23e2807b46abb712ec1cfcee6ac8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CanSeekStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the backend supports seeking for the currently playing stream. </p>
<p>This will enable/disable the rewind/forward buttons in Kodi based on the return value</p>
<dl class="section return"><dt>Returns</dt><dd>false if the PVR addon/backend does not support seeking, true if possible </dd></dl>

</div>
</div>
<a class="anchor" id="ac2158722d1f7f740a518e47b575fb4df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PauseStream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the pvr addon that Kodi (un)paused the currently playing stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paused</td><td>true if stream is paused otherwise false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bed940e124a0ba99a159d1679e5598b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SeekTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backwards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>startpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the pvr addon/demuxer that Kodi wishes to seek the stream by time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The absolute time since stream start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backwards</td><td>True to seek to keyframe BEFORE time, else AFTER </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">startpts</td><td>can be updated to point to where display should start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the seek operation was possible</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if addon has its own demuxer. </dd></dl>

</div>
</div>
<a class="anchor" id="ab20d7d09d75d3f1bf568e7d5475893bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetSpeed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the pvr addon/demuxer that Kodi wishes to change playback speed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>The requested playback speed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if addon has its own demuxer. </dd></dl>

</div>
</div>
<a class="anchor" id="a227f1f5a17b2e2ddc9f35b6ca8196a44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual time_t GetPlayingTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get actual playing time from addon. </p>
<p>With timeshift enabled this is different to live.</p>
<dl class="section return"><dt>Returns</dt><dd>time as UTC </dd></dl>

</div>
</div>
<a class="anchor" id="a80d580744a08d5fcf9773d55a9b49036"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual time_t GetBufferTimeStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get time of oldest packet in timeshift buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>time as UTC </dd></dl>

</div>
</div>
<a class="anchor" id="add87d3c165c0bb6171c39f6ef4f5bdb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual time_t GetBufferTimeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get time of latest packet in timeshift buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>time as UTC </dd></dl>

</div>
</div>
<a class="anchor" id="aa51098c2791f68b2e53f0e0ec88165ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsTimeshifting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if timeshift is active. </p>
<dl class="section return"><dt>Returns</dt><dd>true if timeshift is active </dd></dl>

</div>
</div>
<a class="anchor" id="aad550e498369f3a406296779a162ec04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsRealTimeStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for real-time streaming. </p>
<dl class="section return"><dt>Returns</dt><dd>true if current stream is real-time </dd></dl>

</div>
</div>
<a class="anchor" id="a97826feca391a64d78e922fd2778a12c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OnSystemSleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the pvr addon for power management events. </p>

</div>
</div>
<a class="anchor" id="aefee487397aab89c0515ff3a7e0ffaaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OnSystemWake </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the pvr addon about a system wake event. </p>

</div>
</div>
<a class="anchor" id="a3f7da84be98ff5caee3664d3b3f048ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OnPowerSavingActivated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the pvr addon that power saving becomes activated. </p>

</div>
</div>
<a class="anchor" id="a0f6bfc517164b97eba15cc0e463c43b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OnPowerSavingDeactivated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the pvr addon about power saving becomes deactivated. </p>

</div>
</div>
<a class="anchor" id="a45884e189fad76597699caa992574bef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddMenuHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_v_r___m_e_n_u_h_o_o_k.html">PVR_MENUHOOK</a> *&#160;</td>
          <td class="paramname"><em>hook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or replace a menu hook for the context menu for this add-on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hook</td><td>The hook to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a679068487db30ffd566e43e925ba603a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Recording </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>recordingname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Display a notification in Kodi that a recording started or stopped on the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recordingname</td><td>The name of the recording to display </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename of the recording </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">on</td><td>True when recording started, false when it stopped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a28ab2aa9e2f3191c2d6281cdc680ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TriggerTimerUpdate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request Kodi to update it's list of timers. </p>

</div>
</div>
<a class="anchor" id="a32558a6dec1bee47462379c7fb11dc1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TriggerRecordingUpdate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request Kodi to update it's list of recordings. </p>

</div>
</div>
<a class="anchor" id="a0be8a63a1bde169779281dff66e50014"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TriggerChannelUpdate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request Kodi to update it's list of channels. </p>

</div>
</div>
<a class="anchor" id="a2497b4db59f21f2fbb2956dc016c3067"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TriggerEpgUpdate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channelUid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule an EPG update for the given channel channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channelUid</td><td>The unique id of the channel for this add-on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a935da613c39f91145b6f230728bb1df0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TriggerChannelGroupsUpdate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request Kodi to update it's list of channel groups. </p>

</div>
</div>
<a class="anchor" id="a27de47f3d3787e878ab521d9ca3cf479"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FreeDemuxPacket </td>
          <td>(</td>
          <td class="paramtype">DemuxPacket *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a packet that was allocated with AllocateDemuxPacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The packet to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afab3abc659d82c4f8eea839e37c1dc15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DemuxPacket* AllocateDemuxPacket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>datasize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a demux packet. Free with FreeDemuxPacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">datasize</td><td>The size of the data that will go into the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated packet </dd></dl>

</div>
</div>
<a class="anchor" id="a8ff13d27354254cac06c10b1d70a1dc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConnectionStateChange </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>connectionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVR_CONNECTION_STATE&#160;</td>
          <td class="paramname"><em>newState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify a state change for a PVR backend connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connectionString</td><td>The connection string reported by the backend that can be displayed in the UI. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newState</td><td>The new state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>A localized addon-defined string representing the new state, that can be displayed in the UI or NULL if the Kodi-defined default string for the new state shall be displayed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8795247dea7a40ac72ac8102c06f7cb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EpgEventStateChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_e_p_g___t_a_g.html">EPG_TAG</a> *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uniqueChannelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPG_EVENT_STATE&#160;</td>
          <td class="paramname"><em>newState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify a state change for an EPG event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The EPG event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniqueChannelId</td><td>The unique id of the channel for the EPG event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newState</td><td>The new state. For EPG_EVENT_CREATED and EPG_EVENT_UPDATED, tag must be filled with all available event data, not just a delta. For EPG_EVENT_DELETED, it is sufficient to fill <a class="el" href="struct_e_p_g___t_a_g.html#a268e0b240a6196bd5bef6b53a4daadc8" title="(required) identifier for this event. Valid uids must be greater than EPG_TAG_INVALID_UID. ">EPG_TAG.iUniqueBroadcastId</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/alwin/Development2/kodi6/xbmc/addons/kodi-addon-dev-kit/include/kodi/pvr/<a class="el" href="_p_v_r_client_8h_source.html">PVRClient.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>kodi</b></li><li class="navelem"><b>addon</b></li><li class="navelem"><b>pvr</b></li><li class="navelem"><a class="el" href="classkodi_1_1addon_1_1pvr_1_1_c_addon.html">CAddon</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
