<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Kodi Development: PVR_TIMER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kodi-dev.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kodi Development
   &#160;<span id="projectnumber">17.0</span>
   </div>
   <div id="projectbrief">for Binary (API Level 2) and Script based Add-Ons</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('struct_p_v_r___t_i_m_e_r.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_p_v_r___t_i_m_e_r-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PVR_TIMER</div>  </div>
</div><!--header-->
<div class="contents">

<p>Representation of a timer event.  
 <a href="struct_p_v_r___t_i_m_e_r.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Representation of a timer event. </p>
</div>
<p><code>#include &lt;<a class="el" href="xbmc__pvr__types_8h_source.html">/home/alwin/Mupel/build/kodi-AlwinEsch/kodi-linux-x86_64/xbmc/addons/kodi-addon-dev-kit/kodi/xbmc_pvr_types.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad82db0773f70403b286bd5f2c3863c5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#ad82db0773f70403b286bd5f2c3863c5f">bEndAnyTime</a></td></tr>
<tr class="memdesc:ad82db0773f70403b286bd5f2c3863c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) for EPG based (not Manual) timers indicates endTime does not apply. Default = false  <a href="#ad82db0773f70403b286bd5f2c3863c5f">More...</a><br /></td></tr>
<tr class="separator:ad82db0773f70403b286bd5f2c3863c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e57bc8473273653f3dea214bc803564"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a1e57bc8473273653f3dea214bc803564">bFullTextEpgSearch</a></td></tr>
<tr class="memdesc:a1e57bc8473273653f3dea214bc803564"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) indicates, whether strEpgSearchString is to match against the epg episode title only or also against "other" epg data (backend-dependent)  <a href="#a1e57bc8473273653f3dea214bc803564">More...</a><br /></td></tr>
<tr class="separator:a1e57bc8473273653f3dea214bc803564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d040da25edfd9c7b30e47f641fa1db8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a3d040da25edfd9c7b30e47f641fa1db8">bStartAnyTime</a></td></tr>
<tr class="memdesc:a3d040da25edfd9c7b30e47f641fa1db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) for EPG based (not Manual) timers indicates startTime does not apply. Default = false  <a href="#a3d040da25edfd9c7b30e47f641fa1db8">More...</a><br /></td></tr>
<tr class="separator:a3d040da25edfd9c7b30e47f641fa1db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1e169e482467aaf615639bb3467f09"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a1f1e169e482467aaf615639bb3467f09">endTime</a></td></tr>
<tr class="memdesc:a1f1e169e482467aaf615639bb3467f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) end time of the recording in UTC.  <a href="#a1f1e169e482467aaf615639bb3467f09">More...</a><br /></td></tr>
<tr class="separator:a1f1e169e482467aaf615639bb3467f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822c10930696006667ef88dd7e164e45"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a822c10930696006667ef88dd7e164e45">firstDay</a></td></tr>
<tr class="memdesc:a822c10930696006667ef88dd7e164e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) the first day this timer is active, for repeating timers  <a href="#a822c10930696006667ef88dd7e164e45">More...</a><br /></td></tr>
<tr class="separator:a822c10930696006667ef88dd7e164e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b5023e154e37d721dab50e45100d68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#af3b5023e154e37d721dab50e45100d68">iClientChannelUid</a></td></tr>
<tr class="memdesc:af3b5023e154e37d721dab50e45100d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) unique identifier of the channel to record on. PVR_TIMER_ANY_CHANNEL will denote "any channel", not a specifoc one.  <a href="#af3b5023e154e37d721dab50e45100d68">More...</a><br /></td></tr>
<tr class="separator:af3b5023e154e37d721dab50e45100d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab024c3aa28bad072dd429316e09d74c1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#ab024c3aa28bad072dd429316e09d74c1">iClientIndex</a></td></tr>
<tr class="memdesc:ab024c3aa28bad072dd429316e09d74c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(required) the index of this timer given by the client. PVR_TIMER_NO_CLIENT_INDEX indicates that the index was not yet set by the client, for example for new timers created by Kodi and passed the first time to the client. A valid index must be greater than PVR_TIMER_NO_CLIENT_INDEX.  <a href="#ab024c3aa28bad072dd429316e09d74c1">More...</a><br /></td></tr>
<tr class="separator:ab024c3aa28bad072dd429316e09d74c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e48285cdfd0e726f8f52b2c4b0db8df"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a0e48285cdfd0e726f8f52b2c4b0db8df">iEpgUid</a></td></tr>
<tr class="memdesc:a0e48285cdfd0e726f8f52b2c4b0db8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) epg event id. Use PVR_TIMER_NO_EPG_UID to state that there is no EPG event id available for this timer. Values greater than PVR_TIMER_NO_EPG_UID represent a valid epg event id.  <a href="#a0e48285cdfd0e726f8f52b2c4b0db8df">More...</a><br /></td></tr>
<tr class="separator:a0e48285cdfd0e726f8f52b2c4b0db8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a59e14dd7a234942305274b4de31ec6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a4a59e14dd7a234942305274b4de31ec6">iGenreSubType</a></td></tr>
<tr class="memdesc:a4a59e14dd7a234942305274b4de31ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) genre sub type  <a href="#a4a59e14dd7a234942305274b4de31ec6">More...</a><br /></td></tr>
<tr class="separator:a4a59e14dd7a234942305274b4de31ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fcfda6c86ca6afbf583117363a7bac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#ae1fcfda6c86ca6afbf583117363a7bac">iGenreType</a></td></tr>
<tr class="memdesc:ae1fcfda6c86ca6afbf583117363a7bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) genre type  <a href="#ae1fcfda6c86ca6afbf583117363a7bac">More...</a><br /></td></tr>
<tr class="separator:ae1fcfda6c86ca6afbf583117363a7bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ad6c1ba8e39c8e9e3dd5973e8f4c29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#ac7ad6c1ba8e39c8e9e3dd5973e8f4c29">iLifetime</a></td></tr>
<tr class="memdesc:ac7ad6c1ba8e39c8e9e3dd5973e8f4c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) lifetime of recordings created by this timer. &gt; 0 days after which recordings will be deleted by the backend, &lt; 0 addon defined integer list reference, == 0 disabled  <a href="#ac7ad6c1ba8e39c8e9e3dd5973e8f4c29">More...</a><br /></td></tr>
<tr class="separator:ac7ad6c1ba8e39c8e9e3dd5973e8f4c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713793e59adcfc1657aaa061c453a722"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a713793e59adcfc1657aaa061c453a722">iMarginEnd</a></td></tr>
<tr class="memdesc:a713793e59adcfc1657aaa061c453a722"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) if set, the backend ends the recording iMarginEnd minutes after endTime.  <a href="#a713793e59adcfc1657aaa061c453a722">More...</a><br /></td></tr>
<tr class="separator:a713793e59adcfc1657aaa061c453a722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8340880fa9997b97f6cc10aedc6bc2c7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a8340880fa9997b97f6cc10aedc6bc2c7">iMarginStart</a></td></tr>
<tr class="memdesc:a8340880fa9997b97f6cc10aedc6bc2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) if set, the backend starts the recording iMarginStart minutes before startTime.  <a href="#a8340880fa9997b97f6cc10aedc6bc2c7">More...</a><br /></td></tr>
<tr class="separator:a8340880fa9997b97f6cc10aedc6bc2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67431b013078f7c8fb9e8abf2dc5ac41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a67431b013078f7c8fb9e8abf2dc5ac41">iMaxRecordings</a></td></tr>
<tr class="memdesc:a67431b013078f7c8fb9e8abf2dc5ac41"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) maximum number of recordings this timer shall create. &gt; 0 number of recordings, &lt; 0 addon defined integer list reference, == 0 disabled  <a href="#a67431b013078f7c8fb9e8abf2dc5ac41">More...</a><br /></td></tr>
<tr class="separator:a67431b013078f7c8fb9e8abf2dc5ac41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea32d052ba6903e3da08f64942719ee"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#aaea32d052ba6903e3da08f64942719ee">iParentClientIndex</a></td></tr>
<tr class="memdesc:aaea32d052ba6903e3da08f64942719ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) for timers scheduled by a repeating timer, the index of the repeating timer that scheduled this timer (it's <a class="el" href="struct_p_v_r___t_i_m_e_r.html#ab024c3aa28bad072dd429316e09d74c1" title="(required) the index of this timer given by the client. PVR_TIMER_NO_CLIENT_INDEX indicates that the ...">PVR_TIMER.iClientIndex</a> value). Use PVR_TIMER_NO_PARENT to indicate that this timer was no scheduled by a repeating timer.  <a href="#aaea32d052ba6903e3da08f64942719ee">More...</a><br /></td></tr>
<tr class="separator:aaea32d052ba6903e3da08f64942719ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256bc20804cb086eeffa3f9fc4f76648"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a256bc20804cb086eeffa3f9fc4f76648">iPreventDuplicateEpisodes</a></td></tr>
<tr class="memdesc:a256bc20804cb086eeffa3f9fc4f76648"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) 1 if backend should only record new episodes in case of a repeating epg-based timer, 0 if all episodes shall be recorded (no duplicate detection). Actual algorithm for duplicate detection is defined by the backend. Addons may define own values for different duplicate detection algorithms, thus this is not just a bool.  <a href="#a256bc20804cb086eeffa3f9fc4f76648">More...</a><br /></td></tr>
<tr class="separator:a256bc20804cb086eeffa3f9fc4f76648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad455cbeec0f2922ce65765170c7dc4dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#ad455cbeec0f2922ce65765170c7dc4dc">iPriority</a></td></tr>
<tr class="memdesc:ad455cbeec0f2922ce65765170c7dc4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) the priority of this timer  <a href="#ad455cbeec0f2922ce65765170c7dc4dc">More...</a><br /></td></tr>
<tr class="separator:ad455cbeec0f2922ce65765170c7dc4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab523da5824e07e31b8941059bebb1751"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#ab523da5824e07e31b8941059bebb1751">iRecordingGroup</a></td></tr>
<tr class="memdesc:ab523da5824e07e31b8941059bebb1751"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) integer ref to addon/backend defined list of recording groups  <a href="#ab523da5824e07e31b8941059bebb1751">More...</a><br /></td></tr>
<tr class="separator:ab523da5824e07e31b8941059bebb1751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5204a597d8dc7d18270c825e088ab4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#aac5204a597d8dc7d18270c825e088ab4">iTimerType</a></td></tr>
<tr class="memdesc:aac5204a597d8dc7d18270c825e088ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(required) the type of this timer. It is private to the addon and can be freely defined by the addon. The value must be greater than PVR_TIMER_TYPE_NONE. Kodi does not interpret this value (except for checking for PVR_TIMER_TYPE_NONE), but will pass the right id to the addon with every <a class="el" href="struct_p_v_r___t_i_m_e_r.html" title="Representation of a timer event. ">PVR_TIMER</a> instance, thus the addon easily can determine the timer type.  <a href="#aac5204a597d8dc7d18270c825e088ab4">More...</a><br /></td></tr>
<tr class="separator:aac5204a597d8dc7d18270c825e088ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58923618a8d3212d05f1598671eec807"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a58923618a8d3212d05f1598671eec807">iWeekdays</a></td></tr>
<tr class="memdesc:a58923618a8d3212d05f1598671eec807"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) week days, for repeating timers  <a href="#a58923618a8d3212d05f1598671eec807">More...</a><br /></td></tr>
<tr class="separator:a58923618a8d3212d05f1598671eec807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf564fc30a2a8624cf917e282281a500"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#aaf564fc30a2a8624cf917e282281a500">startTime</a></td></tr>
<tr class="memdesc:aaf564fc30a2a8624cf917e282281a500"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) start time of the recording in UTC. Instant timers that are sent to the add-on by Kodi will have this value set to 0.  <a href="#aaf564fc30a2a8624cf917e282281a500">More...</a><br /></td></tr>
<tr class="separator:aaf564fc30a2a8624cf917e282281a500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048327d0a31f8b2eb735730588de39cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xbmc__pvr__types_8h.html#a13841ca455933a42daf0ab20ea26895b">PVR_TIMER_STATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a048327d0a31f8b2eb735730588de39cc">state</a></td></tr>
<tr class="memdesc:a048327d0a31f8b2eb735730588de39cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(required) the state of this timer  <a href="#a048327d0a31f8b2eb735730588de39cc">More...</a><br /></td></tr>
<tr class="separator:a048327d0a31f8b2eb735730588de39cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab5a5811eac9c4afe1a39a2f3f0108d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a2ab5a5811eac9c4afe1a39a2f3f0108d">strDirectory</a> [<a class="el" href="xbmc__pvr__types_8h.html#a2a73fd9092e1fc9840a732d01cdd9e92">PVR_ADDON_URL_STRING_LENGTH</a>]</td></tr>
<tr class="memdesc:a2ab5a5811eac9c4afe1a39a2f3f0108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) the (relative) directory where the recording will be stored in  <a href="#a2ab5a5811eac9c4afe1a39a2f3f0108d">More...</a><br /></td></tr>
<tr class="separator:a2ab5a5811eac9c4afe1a39a2f3f0108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30cc070bb955fef90581c470d909db3"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#af30cc070bb955fef90581c470d909db3">strEpgSearchString</a> [<a class="el" href="xbmc__pvr__types_8h.html#a988e027ffc35b0a5ab26234a46ae5840">PVR_ADDON_NAME_STRING_LENGTH</a>]</td></tr>
<tr class="memdesc:af30cc070bb955fef90581c470d909db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) a string used to search epg data for repeating epg-based timers. Format is backend-dependent, for example regexp  <a href="#af30cc070bb955fef90581c470d909db3">More...</a><br /></td></tr>
<tr class="separator:af30cc070bb955fef90581c470d909db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2313b47118e67d09bd32a710fcbd6f4"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#ab2313b47118e67d09bd32a710fcbd6f4">strSummary</a> [<a class="el" href="xbmc__pvr__types_8h.html#a18846516f943a5da5cd57e21a997c761">PVR_ADDON_DESC_STRING_LENGTH</a>]</td></tr>
<tr class="memdesc:ab2313b47118e67d09bd32a710fcbd6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) the summary for this timer  <a href="#ab2313b47118e67d09bd32a710fcbd6f4">More...</a><br /></td></tr>
<tr class="separator:ab2313b47118e67d09bd32a710fcbd6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dde00b3f85145c5749e79f4dbbb4e4"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_v_r___t_i_m_e_r.html#a18dde00b3f85145c5749e79f4dbbb4e4">strTitle</a> [<a class="el" href="xbmc__pvr__types_8h.html#a988e027ffc35b0a5ab26234a46ae5840">PVR_ADDON_NAME_STRING_LENGTH</a>]</td></tr>
<tr class="memdesc:a18dde00b3f85145c5749e79f4dbbb4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(required) a title for this timer  <a href="#a18dde00b3f85145c5749e79f4dbbb4e4">More...</a><br /></td></tr>
<tr class="separator:a18dde00b3f85145c5749e79f4dbbb4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad82db0773f70403b286bd5f2c3863c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bEndAnyTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) for EPG based (not Manual) timers indicates endTime does not apply. Default = false </p>

</div>
</div>
<a class="anchor" id="a1e57bc8473273653f3dea214bc803564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bFullTextEpgSearch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) indicates, whether strEpgSearchString is to match against the epg episode title only or also against "other" epg data (backend-dependent) </p>

</div>
</div>
<a class="anchor" id="a3d040da25edfd9c7b30e47f641fa1db8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bStartAnyTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) for EPG based (not Manual) timers indicates startTime does not apply. Default = false </p>

</div>
</div>
<a class="anchor" id="a1f1e169e482467aaf615639bb3467f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t endTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) end time of the recording in UTC. </p>

</div>
</div>
<a class="anchor" id="a822c10930696006667ef88dd7e164e45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t firstDay</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) the first day this timer is active, for repeating timers </p>

</div>
</div>
<a class="anchor" id="af3b5023e154e37d721dab50e45100d68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iClientChannelUid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) unique identifier of the channel to record on. PVR_TIMER_ANY_CHANNEL will denote "any channel", not a specifoc one. </p>

</div>
</div>
<a class="anchor" id="ab024c3aa28bad072dd429316e09d74c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iClientIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(required) the index of this timer given by the client. PVR_TIMER_NO_CLIENT_INDEX indicates that the index was not yet set by the client, for example for new timers created by Kodi and passed the first time to the client. A valid index must be greater than PVR_TIMER_NO_CLIENT_INDEX. </p>

</div>
</div>
<a class="anchor" id="a0e48285cdfd0e726f8f52b2c4b0db8df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iEpgUid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) epg event id. Use PVR_TIMER_NO_EPG_UID to state that there is no EPG event id available for this timer. Values greater than PVR_TIMER_NO_EPG_UID represent a valid epg event id. </p>

</div>
</div>
<a class="anchor" id="a4a59e14dd7a234942305274b4de31ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iGenreSubType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) genre sub type </p>

</div>
</div>
<a class="anchor" id="ae1fcfda6c86ca6afbf583117363a7bac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iGenreType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) genre type </p>

</div>
</div>
<a class="anchor" id="ac7ad6c1ba8e39c8e9e3dd5973e8f4c29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iLifetime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) lifetime of recordings created by this timer. &gt; 0 days after which recordings will be deleted by the backend, &lt; 0 addon defined integer list reference, == 0 disabled </p>

</div>
</div>
<a class="anchor" id="a713793e59adcfc1657aaa061c453a722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iMarginEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) if set, the backend ends the recording iMarginEnd minutes after endTime. </p>

</div>
</div>
<a class="anchor" id="a8340880fa9997b97f6cc10aedc6bc2c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iMarginStart</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) if set, the backend starts the recording iMarginStart minutes before startTime. </p>

</div>
</div>
<a class="anchor" id="a67431b013078f7c8fb9e8abf2dc5ac41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iMaxRecordings</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) maximum number of recordings this timer shall create. &gt; 0 number of recordings, &lt; 0 addon defined integer list reference, == 0 disabled </p>

</div>
</div>
<a class="anchor" id="aaea32d052ba6903e3da08f64942719ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iParentClientIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) for timers scheduled by a repeating timer, the index of the repeating timer that scheduled this timer (it's <a class="el" href="struct_p_v_r___t_i_m_e_r.html#ab024c3aa28bad072dd429316e09d74c1" title="(required) the index of this timer given by the client. PVR_TIMER_NO_CLIENT_INDEX indicates that the ...">PVR_TIMER.iClientIndex</a> value). Use PVR_TIMER_NO_PARENT to indicate that this timer was no scheduled by a repeating timer. </p>

</div>
</div>
<a class="anchor" id="a256bc20804cb086eeffa3f9fc4f76648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iPreventDuplicateEpisodes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) 1 if backend should only record new episodes in case of a repeating epg-based timer, 0 if all episodes shall be recorded (no duplicate detection). Actual algorithm for duplicate detection is defined by the backend. Addons may define own values for different duplicate detection algorithms, thus this is not just a bool. </p>

</div>
</div>
<a class="anchor" id="ad455cbeec0f2922ce65765170c7dc4dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iPriority</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) the priority of this timer </p>

</div>
</div>
<a class="anchor" id="ab523da5824e07e31b8941059bebb1751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iRecordingGroup</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) integer ref to addon/backend defined list of recording groups </p>

</div>
</div>
<a class="anchor" id="aac5204a597d8dc7d18270c825e088ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iTimerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(required) the type of this timer. It is private to the addon and can be freely defined by the addon. The value must be greater than PVR_TIMER_TYPE_NONE. Kodi does not interpret this value (except for checking for PVR_TIMER_TYPE_NONE), but will pass the right id to the addon with every <a class="el" href="struct_p_v_r___t_i_m_e_r.html" title="Representation of a timer event. ">PVR_TIMER</a> instance, thus the addon easily can determine the timer type. </p>

</div>
</div>
<a class="anchor" id="a58923618a8d3212d05f1598671eec807"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iWeekdays</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) week days, for repeating timers </p>

</div>
</div>
<a class="anchor" id="aaf564fc30a2a8624cf917e282281a500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t startTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) start time of the recording in UTC. Instant timers that are sent to the add-on by Kodi will have this value set to 0. </p>

</div>
</div>
<a class="anchor" id="a048327d0a31f8b2eb735730588de39cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xbmc__pvr__types_8h.html#a13841ca455933a42daf0ab20ea26895b">PVR_TIMER_STATE</a> state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(required) the state of this timer </p>

</div>
</div>
<a class="anchor" id="a2ab5a5811eac9c4afe1a39a2f3f0108d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char strDirectory[<a class="el" href="xbmc__pvr__types_8h.html#a2a73fd9092e1fc9840a732d01cdd9e92">PVR_ADDON_URL_STRING_LENGTH</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) the (relative) directory where the recording will be stored in </p>

</div>
</div>
<a class="anchor" id="af30cc070bb955fef90581c470d909db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char strEpgSearchString[<a class="el" href="xbmc__pvr__types_8h.html#a988e027ffc35b0a5ab26234a46ae5840">PVR_ADDON_NAME_STRING_LENGTH</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) a string used to search epg data for repeating epg-based timers. Format is backend-dependent, for example regexp </p>

</div>
</div>
<a class="anchor" id="ab2313b47118e67d09bd32a710fcbd6f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char strSummary[<a class="el" href="xbmc__pvr__types_8h.html#a18846516f943a5da5cd57e21a997c761">PVR_ADDON_DESC_STRING_LENGTH</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) the summary for this timer </p>

</div>
</div>
<a class="anchor" id="a18dde00b3f85145c5749e79f4dbbb4e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char strTitle[<a class="el" href="xbmc__pvr__types_8h.html#a988e027ffc35b0a5ab26234a46ae5840">PVR_ADDON_NAME_STRING_LENGTH</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(required) a title for this timer </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/alwin/Mupel/build/kodi-AlwinEsch/kodi-linux-x86_64/xbmc/addons/kodi-addon-dev-kit/kodi/<a class="el" href="xbmc__pvr__types_8h_source.html">xbmc_pvr_types.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
